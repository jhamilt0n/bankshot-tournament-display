<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bankshot Tournament Director Console</title>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Oswald:wght@400;500;600;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary: #1e7e34;
            --primary-dark: #0d5c26;
            --secondary: #0ea5e9;
            --danger: #ef4444;
            --warning: #f59e0b;
            --success: #10b981;
            --bg: #f3f4f6;
            --card-bg: #ffffff;
            --text: #1f2937;
            --text-light: #6b7280;
            --border: #e5e7eb;
        }
        
        body {
            font-family: 'Roboto', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            margin: 0;
        }
        
        /* App Layout */
        .app-layout {
            display: flex;
            min-height: 100vh;
        }
        
        /* Sidebar */
        .sidebar {
            width: 300px;
            background: linear-gradient(180deg, #1a472a 0%, #0d3320 100%);
            color: white;
            display: flex;
            flex-direction: column;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            z-index: 100;
        }
        
        .sidebar-header {
            padding: 20px;
            text-align: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .sidebar-logo {
            width: 120px;
            height: auto;
            margin-bottom: 10px;
        }
        
        .sidebar-qr {
            width: 140px;
            height: 140px;
            margin-bottom: 10px;
            border-radius: 8px;
            background: white;
            padding: 8px;
        }
        
        .sidebar-qr-label {
            font-size: 0.75rem;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        .sidebar-header h2 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            letter-spacing: 2px;
            margin: 0;
            opacity: 0.9;
        }
        
        .sidebar-section {
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .sidebar-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.6;
            margin-bottom: 10px;
        }
        
        /* Event Type Buttons */
        .event-type-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .event-type-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 12px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            text-align: left;
            transition: all 0.2s;
        }
        
        .event-type-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .event-type-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            box-shadow: 0 2px 8px rgba(30, 126, 52, 0.4);
        }
        
        /* Tournament List */
        .tournament-list {
            margin-top: 10px;
        }
        
        .tournament-item {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 10px 12px;
            border-radius: 6px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tournament-item:hover {
            background: rgba(255,255,255,0.15);
        }
        
        .tournament-item.active {
            background: var(--secondary);
            border-color: var(--secondary);
        }
        
        .tournament-item-name {
            font-weight: 500;
            font-size: 0.9rem;
        }
        
        .tournament-item-date {
            font-size: 0.75rem;
            opacity: 0.7;
            margin-top: 2px;
        }
        
        .tournament-loading {
            text-align: center;
            padding: 15px;
            opacity: 0.6;
            font-size: 0.85rem;
        }
        
        /* Sidebar Navigation */
        .sidebar-nav {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .sidebar-tab {
            background: transparent;
            border: none;
            color: white;
            padding: 12px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            text-align: left;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .sidebar-tab:hover {
            background: rgba(255,255,255,0.1);
        }
        
        .sidebar-tab.active {
            background: rgba(255,255,255,0.2);
            font-weight: 500;
        }
        
        .sidebar-tab.disabled {
            opacity: 0.4;
            pointer-events: none;
        }
        
        .sidebar-badge {
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            min-width: 24px;
            text-align: center;
        }
        
        /* Sidebar Settings */
        .sidebar-settings {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .sidebar-setting {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .sidebar-setting label {
            font-size: 0.85rem;
        }
        
        .input-group-small {
            display: flex;
            align-items: center;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            padding: 0 8px;
        }
        
        .input-group-small span {
            font-size: 0.85rem;
            opacity: 0.7;
        }
        
        .input-group-small input {
            background: transparent;
            border: none;
            color: white;
            width: 60px;
            padding: 8px 5px;
            font-size: 0.9rem;
            text-align: right;
        }
        
        .input-group-small input:focus {
            outline: none;
        }
        
        /* Sidebar Action Buttons */
        .sidebar-action-btn {
            display: block;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            text-align: left;
            transition: all 0.2s;
            margin-bottom: 8px;
            width: 100%;
        }
        
        .sidebar-action-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .sidebar-action-btn.danger-btn {
            margin-top: 10px;
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.4);
        }
        
        .sidebar-action-btn.danger-btn:hover {
            background: rgba(239, 68, 68, 0.4);
        }
        
        /* Sidebar Status */
        .sidebar-status {
            padding: 15px 20px;
            background: rgba(0,0,0,0.2);
            font-size: 0.8rem;
            text-align: center;
            margin-top: auto;
        }
        
        /* Main Content */
        .main-content {
            flex: 1;
            margin-left: 300px;
            padding: 20px;
            min-height: 100vh;
        }
        
        /* Hide old elements */
        .header, .tabs, .settings-bar {
            display: none !important;
        }
            min-width: 200px;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: var(--secondary);
            color: white;
        }
        
        .btn-primary:hover {
            background: #0284c7;
        }
        
        .btn-success {
            background: var(--success);
            color: white;
        }
        
        .btn-danger {
            background: var(--danger);
            color: white;
        }
        
        .btn-warning {
            background: var(--warning);
            color: white;
        }
        
        .btn-small {
            padding: 4px 10px;
            font-size: 0.8rem;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            background: white;
            border-bottom: 2px solid var(--border);
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .tab {
            padding: 15px 20px;
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-light);
            border: none;
            background: none;
            cursor: pointer;
            white-space: nowrap;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
        }
        
        .tab:hover {
            color: var(--primary);
        }
        
        .tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }
        
        .tab-badge {
            background: var(--danger);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            margin-left: 5px;
        }
        
        /* Tab Content */
        .tab-content {
            display: none;
            padding: 20px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Cards */
        .card {
            background: var(--card-bg);
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 20px;
            overflow: hidden;
        }
        
        .card-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 12px 15px;
            font-family: 'Oswald', sans-serif;
            font-size: 1.1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .card-body {
            padding: 15px;
        }
        
        /* Form Elements */
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            font-weight: 500;
            margin-bottom: 5px;
            color: var(--text);
        }
        
        .form-control {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.2s;
        }
        
        .form-control:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        /* Autocomplete */
        .autocomplete-wrapper {
            position: relative;
        }
        
        .autocomplete-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid var(--primary);
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 50;
            display: none;
        }
        
        .autocomplete-list.show {
            display: block;
        }
        
        .autocomplete-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
        }
        
        .autocomplete-item:hover, .autocomplete-item.selected {
            background: #e8f5e9;
        }
        
        .autocomplete-item .name {
            font-weight: 500;
        }
        
        .autocomplete-item .phone {
            font-size: 0.85rem;
            color: var(--text-light);
        }
        
        /* Player List */
        .player-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .player-row {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid var(--border);
            gap: 10px;
        }
        
        .player-row:last-child {
            border-bottom: none;
        }
        
        .player-row.checked-in {
            background: #d1fae5;
        }
        
        .player-row.not-paid {
            background: #fef3c7;
        }
        
        .player-checkbox {
            width: 22px;
            height: 22px;
            cursor: pointer;
        }
        
        .player-info {
            flex: 1;
        }
        
        .player-name {
            font-weight: 500;
            font-size: 1rem;
        }
        
        .player-phone {
            font-size: 0.85rem;
            color: var(--text-light);
        }
        
        .player-skill {
            background: var(--secondary);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .player-actions {
            display: flex;
            gap: 5px;
        }
        
        /* Calcutta Table */
        .calcutta-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .calcutta-table th, .calcutta-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        
        .calcutta-table th {
            background: #f9fafb;
            font-weight: 600;
            position: sticky;
            top: 0;
        }
        
        .calcutta-table tr.unpaid {
            background: #fff3cd;
        }
        
        .calcutta-table tr.pool-row {
            background: #e0f2fe;
            opacity: 0.7;
        }
        
        .calcutta-table tr.pool-summary-row {
            background: #fef3c7 !important;
        }
        
        .calcutta-table input[type="text"],
        .calcutta-table input[type="number"] {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
        }
        
        .calcutta-table .skill-input {
            width: 60px !important;
            text-align: center;
            font-weight: 500;
        }
        
        .calcutta-table .skill-input.no-skill {
            border-color: #f59e0b;
            background: #fffbeb;
        }
        
        .calcutta-table input[type="text"]:focus,
        .calcutta-table input[type="number"]:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        /* Summary Cards */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .summary-card {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .summary-card.secondary {
            background: linear-gradient(135deg, var(--secondary) 0%, #0284c7 100%);
        }
        
        .summary-card.warning {
            background: linear-gradient(135deg, var(--warning) 0%, #d97706 100%);
        }
        
        .summary-value {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2.5rem;
            line-height: 1;
        }
        
        .summary-label {
            font-size: 0.85rem;
            opacity: 0.9;
            margin-top: 5px;
        }
        
        /* Buyer Summary */
        .buyer-summary {
            margin-top: 20px;
        }
        
        .buyer-row {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid var(--border);
            gap: 10px;
        }
        
        .buyer-row.paid {
            background: #d1fae5;
        }
        
        .buyer-row.unpaid {
            background: #fef3c7;
        }
        
        .buyer-name {
            flex: 1;
            font-weight: 500;
        }
        
        .buyer-amount {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            color: var(--primary);
        }
        
        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
            padding: 20px;
        }
        
        .modal-overlay.show {
            display: flex;
        }
        
        .modal {
            background: white;
            border-radius: 12px;
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 15px 20px;
            font-family: 'Oswald', sans-serif;
            font-size: 1.2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            line-height: 1;
        }
        
        .modal-body {
            padding: 20px;
        }
        
        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        /* Settings */
        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid var(--border);
        }
        
        .setting-row:last-child {
            border-bottom: none;
        }
        
        .setting-label {
            font-weight: 500;
        }
        
        .setting-value input {
            width: 80px;
            padding: 6px 10px;
            border: 2px solid var(--border);
            border-radius: 4px;
            text-align: center;
        }
        
        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 300;
        }
        
        .toast {
            background: var(--text);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            margin-top: 10px;
            animation: slideIn 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .toast.success {
            background: var(--success);
        }
        
        .toast.error {
            background: var(--danger);
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* Loading */
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-light);
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Responsive */
        @media (max-width: 600px) {
            .header h1 {
                font-size: 1.4rem;
            }
            
            .tab {
                padding: 12px 15px;
                font-size: 0.9rem;
            }
            
            .summary-value {
                font-size: 2rem;
            }
            
            .player-row {
                flex-wrap: wrap;
            }
            
            .calcutta-table {
                font-size: 0.85rem;
            }
            
            .calcutta-table th, .calcutta-table td {
                padding: 8px 5px;
            }
        }
        
        /* Sort buttons */
        .sort-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .sort-btn {
            padding: 6px 12px;
            border: 2px solid var(--border);
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        
        .sort-btn.active {
            border-color: var(--primary);
            background: #e8f5e9;
        }
        
        /* Inline edit */
        .inline-edit {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .inline-edit input {
            padding: 4px 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            width: 120px;
        }
        
        /* FargoRate Results */
        .fargo-results {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }
        
        .fargo-result-item {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border: 2px solid var(--border);
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .fargo-result-item:hover {
            border-color: var(--primary);
            background: #e8f5e9;
        }
        
        .fargo-info {
            flex: 1;
        }
        
        .fargo-name {
            font-weight: 600;
            font-size: 1.1rem;
        }
        
        .fargo-location {
            font-size: 0.85rem;
            color: var(--text-light);
        }
        
        .fargo-rating {
            background: linear-gradient(135deg, var(--secondary) 0%, #0284c7 100%);
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
        }
        
        .no-results {
            text-align: center;
            padding: 20px;
            color: var(--text-light);
        }
        
        /* Settings Bar */
        .settings-bar {
            display: flex;
            gap: 20px;
            align-items: flex-end;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .setting-item label {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-light);
        }
        
        .input-group {
            display: flex;
            align-items: center;
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .input-prefix {
            padding: 8px 10px;
            background: var(--border);
            font-weight: 600;
            color: var(--text);
        }
        
        .input-group input {
            border: none;
            padding: 8px 10px;
            width: 80px;
            font-size: 1rem;
            background: transparent;
        }
        
        .input-group input:focus {
            outline: none;
        }
        
        /* Summary Grid 4 columns */
        .summary-grid-4 {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 600px) {
            .summary-grid-4 {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* Spreadsheet */
        .spreadsheet-container {
            overflow-x: auto;
            max-height: 600px;
            overflow-y: auto;
            position: relative;
        }
        
        /* Allow autocomplete to overflow the container */
        .spreadsheet-container:has(.inline-autocomplete-list.show) {
            overflow: visible;
        }
        
        .spreadsheet {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
        }
        
        .spreadsheet th {
            background: #f1f5f9;
            padding: 10px 8px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            border-bottom: 2px solid var(--border);
        }
        
        .spreadsheet td {
            padding: 4px 6px;
            border-bottom: 1px solid var(--border);
            vertical-align: middle;
        }
        
        .spreadsheet tr:hover {
            background: #f8fafc;
        }
        
        .spreadsheet tr.paid-row {
            background: #d1fae5;
        }
        
        .spreadsheet tr.unpaid-row {
            background: #fef3c7;
        }
        
        .spreadsheet input[type="text"],
        .spreadsheet input[type="tel"] {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid transparent;
            border-radius: 4px;
            font-size: 0.95rem;
            background: transparent;
        }
        
        .spreadsheet input[type="text"]:focus,
        .spreadsheet input[type="tel"]:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
        }
        
        .spreadsheet input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .spreadsheet .row-number {
            color: var(--text-light);
            font-weight: 500;
            text-align: center;
        }
        
        .spreadsheet .fargo-display {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
            color: var(--secondary);
        }
        
        .spreadsheet .delete-btn {
            background: none;
            border: none;
            color: var(--danger);
            cursor: pointer;
            padding: 5px;
            font-size: 1.2rem;
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        
        .spreadsheet .delete-btn:hover {
            opacity: 1;
        }
        
        .spreadsheet .edit-btn {
            background: none;
            border: none;
            color: var(--primary);
            cursor: pointer;
            padding: 5px;
            font-size: 1rem;
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        
        .spreadsheet .edit-btn:hover {
            opacity: 1;
        }
        
        .spreadsheet .carrier-select {
            width: 100%;
            padding: 6px 4px;
            border: 1px solid transparent;
            border-radius: 4px;
            font-size: 0.85rem;
            background: transparent;
            cursor: pointer;
        }
        
        .spreadsheet .carrier-select:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
        }
        
        .spreadsheet .carrier-select:disabled {
            cursor: default;
            opacity: 0.5;
        }
        
        .spreadsheet .empty-row input {
            color: var(--text-light);
        }
        
        /* Inline autocomplete for spreadsheet */
        .inline-autocomplete {
            position: relative;
        }
        
        .inline-autocomplete {
            position: relative;
        }
        
        .inline-autocomplete-list {
            position: fixed;
            background: white;
            border: 2px solid var(--primary);
            border-radius: 6px;
            max-height: 400px;
            min-width: 280px;
            overflow-y: auto;
            z-index: 9999;
            display: none;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        }
        
        .inline-autocomplete-list.show {
            display: block;
        }
        
        .inline-autocomplete-item {
            padding: 12px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
        }
        
        .inline-autocomplete-item:hover {
            background: #e8f5e9;
        }
        
        .inline-autocomplete-item:last-child {
            border-bottom: none;
        }
        
        .inline-autocomplete-item .player-name {
            font-weight: 600;
            font-size: 1rem;
        }
        
        .inline-autocomplete-item .player-details {
            font-size: 0.85rem;
            color: var(--text-light);
            margin-top: 2px;
        }
        
        .inline-autocomplete-item .fargo-badge {
            background: var(--secondary);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.85rem;
        }
        
        /* Payouts Grid */
        .payouts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 10px;
            padding: 15px;
        }
        
        .payout-item {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }
        
        .payout-item.first-place {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-color: #f59e0b;
        }
        
        .payout-item.second-place {
            background: linear-gradient(135deg, #e5e7eb 0%, #d1d5db 100%);
            border-color: #9ca3af;
        }
        
        .payout-item.third-place {
            background: linear-gradient(135deg, #fed7aa 0%, #fdba74 100%);
            border-color: #f97316;
        }
        
        .payout-place {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-light);
            margin-bottom: 4px;
        }
        
        .payout-amount {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.6rem;
            color: var(--primary-dark);
        }
        
        .payout-placeholder {
            grid-column: 1 / -1;
            text-align: center;
            padding: 30px;
            color: var(--text-light);
            font-style: italic;
        }
        
        /* Buyer autocomplete in table */
        .buyer-autocomplete-wrapper {
            position: relative;
        }
        
        .buyer-autocomplete-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid var(--primary);
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 9999;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .buyer-autocomplete-list.show {
            display: block;
        }
        
        .buyer-option {
            padding: 8px 10px;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            font-size: 0.9rem;
        }
        
        .buyer-option:hover {
            background: #e8f5e9;
        }
        
        .buyer-option.free-entry {
            color: var(--text-light);
            font-style: italic;
        }
        
        /* Calcutta Live Display Styles */
        .calcutta-disabled {
            position: relative;
        }
        
        .calcutta-disabled::after {
            content: 'Click "Start Calcutta" to begin auction';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(128, 128, 128, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: #4b5563;
            font-weight: 500;
            z-index: 10;
            border-radius: 0 0 10px 10px;
        }
        
        .calcutta-disabled input,
        .calcutta-disabled select,
        .calcutta-disabled button {
            pointer-events: none;
        }
        
        .start-calcutta-container {
            text-align: center;
            padding: 15px;
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-bottom: 2px solid #f59e0b;
        }
        
        .start-calcutta-btn {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            letter-spacing: 3px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
            text-transform: uppercase;
        }
        
        .start-calcutta-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 158, 11, 0.5);
        }
        
        .start-calcutta-btn.active {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            box-shadow: 0 4px 15px rgba(220, 38, 38, 0.4);
            animation: pulse-live 2s infinite;
        }
        
        @keyframes pulse-live {
            0%, 100% { box-shadow: 0 4px 15px rgba(220, 38, 38, 0.4); }
            50% { box-shadow: 0 4px 25px rgba(220, 38, 38, 0.7); }
        }
        
        .calcutta-status-text {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #92400e;
        }
        
        .calcutta-status-text.active {
            color: #dc2626;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <!-- Main Layout Container -->
    <div class="app-layout">
        <!-- Left Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <img src="https://raw.githubusercontent.com/jhamilt0n/bankshot-tournament-display/main/assets/Bankshot_Logo.png" alt="Bankshot" class="sidebar-logo" id="sidebarLogo">
                <div id="sidebarQR" style="display:none;" title="Players can scan to register for this tournament">
                    <img src="https://api.qrserver.com/v1/create-qr-code/?size=140x140&data=https://jhamilt0n.github.io/tournamentwatcher/" alt="Register" class="sidebar-qr">
                    <div class="sidebar-qr-label">Scan to Register</div>
                </div>
                <h2>Tournament Console</h2>
            </div>
            
            <!-- Event Type Selection -->
            <div class="sidebar-section">
                <div class="sidebar-label">Event Type</div>
                <div class="event-type-buttons">
                    <button class="event-type-btn" id="btnRecurring" onclick="selectEventType('recurring')" title="For weekly or monthly events that are open with a single player. No teams.">
                        üîÑ Recurring Tournament
                    </button>
                    <button class="event-type-btn" id="btnSpecial" onclick="selectEventType('special')" title="For pre-registered tournaments with teams or special formats">
                        ‚≠ê Special Event
                    </button>
                </div>
                
                <!-- Special Event Tournament List (hidden by default) -->
                <div class="tournament-list" id="tournamentList" style="display:none;">
                    <div class="sidebar-label" style="margin-top:10px;">Select Tournament</div>
                    <div id="tournamentListItems">
                        <div class="tournament-loading">Loading tournaments...</div>
                    </div>
                </div>
            </div>
            
            <!-- Navigation Tabs -->
            <div class="sidebar-section">
                <div class="sidebar-label">Navigation</div>
                <nav class="sidebar-nav">
                    <button class="sidebar-tab active" data-tab="checkin" onclick="switchTab('checkin')" title="Mark players as paid or late to include them in the tournament">
                        üìã Check-In <span class="sidebar-badge" id="checkinCount">0</span>
                    </button>
                    <button class="sidebar-tab" data-tab="sidepot" onclick="switchTab('sidepot')" title="Manage optional side pot entries for checked-in players">
                        üí∞ Side Pot <span class="sidebar-badge" id="sidepotCount">0</span>
                    </button>
                    <button class="sidebar-tab" data-tab="calcutta" onclick="switchTab('calcutta')" title="Run the player auction - only paid or late players appear here">
                        üéØ Calcutta
                    </button>
                    <button class="sidebar-tab" data-tab="buyers" onclick="switchTab('buyers')" title="View all Calcutta buyers and their purchased players">
                        üõí Buyers <span class="sidebar-badge" id="unpaidCount">0</span>
                    </button>
                </nav>
            </div>
            
            <!-- Tournament Settings -->
            <div class="sidebar-section">
                <div class="sidebar-label">Tournament Settings</div>
                <div class="sidebar-settings">
                    <div class="sidebar-setting" title="Tournament entry fee per player">
                        <label>Entry Fee <span id="dayIndicator" style="font-size:0.7rem;opacity:0.7;"></span></label>
                        <div class="input-group-small">
                            <span>$</span>
                            <input type="number" id="entryFeeInput" min="5" step="5" onchange="updateTournamentSettings()">
                        </div>
                    </div>
                    <div class="sidebar-setting" id="sidepotSetting" title="Optional side pot amount per player">
                        <label>Side Pot</label>
                        <div class="input-group-small">
                            <span>$</span>
                            <input type="number" id="sidepotInput" value="5" min="1" step="1" onchange="updateTournamentSettings()">
                        </div>
                    </div>
                    <div class="sidebar-setting" id="addedMoneySetting" style="display:none;" title="Added money for special event prize pool">
                        <label>Added Money</label>
                        <div class="input-group-small">
                            <span>$</span>
                            <input type="number" id="addedMoneyInput" value="0" min="0" step="5" onchange="updateTournamentSettings()">
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Quick Actions -->
            <div class="sidebar-section">
                <div class="sidebar-label">Actions</div>
                <button class="sidebar-action-btn" id="btnAddPlayer" onclick="showAddNewPlayerModal()" title="Add a new player and check them in">
                    ‚ûï Add New Player
                </button>
                <a href="https://jhamilt0n.github.io/tournamentwatcher/" target="_blank" class="sidebar-action-btn" id="btnAddRegistration" style="display:none; text-decoration:none;" title="Opens registration form to add players or teams to this tournament">
                    ‚ûï Add Registration
                </a>
                <button class="sidebar-action-btn" onclick="downloadPlayersCSV()" title="Export paid and late players only - triggers bracket display update">
                    üì• Download CSV
                </button>
                <a href="https://docs.google.com/spreadsheets/d/1UVH0Yv-I8usR-1OIA0uEdgeAAjiG8rGE5c0N45o2AOo/edit" target="_blank" class="sidebar-action-btn" id="btnPlayerDB" style="text-decoration:none;" title="Open the spreadsheet to manually update player">
                    üìã Player Database
                </a>
                <button class="sidebar-action-btn danger-btn" onclick="clearAllData()" title="Clear all check-ins, Calcutta bids, and side pot entries for this tournament">
                    üóëÔ∏è Clear Tournament
                </button>
                <a href="https://docs.google.com/spreadsheets/d/1MUC0HUzKql6UxVOJQL55ooz5VlBLf097jktD_TTwCfM/edit?gid=2019392543#gid=2019392543" target="_blank" class="sidebar-action-btn" style="text-decoration:none;" title="Open the Tournaments sheet to add a new special event">
                    üìÖ Add Special Event
                </a>
                <a href="/media_manager.html" target="_blank" class="sidebar-action-btn" style="text-decoration:none;" title="Manage media rotation for TV displays">
                    üé¨ Media Manager
                </a>
            </div>
            
            <!-- Status Info -->
            <div class="sidebar-status" id="headerInfo">
                Select event type to begin
            </div>
        </aside>
        
        <!-- Main Content Area -->
        <main class="main-content">
            <!-- Tournament Name Banner -->
            <div id="tournamentBanner" style="background: linear-gradient(135deg, #1e7e34 0%, #0d5c26 100%); color: white; padding: 15px 20px; margin-bottom: 20px; border-radius: 10px; text-align: center; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
                <div style="font-family: Bebas Neue, sans-serif; font-size: 2.5rem; letter-spacing: 2px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);" id="tournamentNameDisplay">Loading tournament...</div>
            </div>
            <!-- Check-In Tab -->
            <div class="tab-content active" id="tab-checkin">
        
        <!-- Summary Cards -->
        <div class="summary-grid-4">
            <div class="summary-card" title="Total players checked in">
                <div class="summary-value" id="totalPlayers">0</div>
                <div class="summary-label">Players</div>
            </div>
            <div class="summary-card secondary" title="Total entry fees from paid players">
                <div class="summary-value" id="totalCollected">$0</div>
                <div class="summary-label">Entry Collected</div>
            </div>
            <div class="summary-card" style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);" title="Total collected from side pot entries">
                <div class="summary-value" id="sidepotCollected">$0</div>
                <div class="summary-label">Side Pot</div>
            </div>
            <div class="summary-card warning" title="Players checked in but not yet paid">
                <div class="summary-value" id="unpaidEntries">0</div>
                <div class="summary-label">Unpaid</div>
            </div>
        </div>
        
        <!-- Player Entry Spreadsheet -->
        <div class="card">
            <div class="card-header">
                <span>Player Check-In</span>
                <span>
                    <span id="dbPlayerCount" style="font-size:0.8rem; color:#6b7280; margin-right:10px;">DB: 0</span>
                    <span id="playerCountDisplay">0 players</span>
                </span>
            </div>
            <div class="spreadsheet-container">
                <table class="spreadsheet" id="playerSpreadsheet">
                    <thead>
                        <tr>
                            <th style="width:4%">#</th>
                            <th style="width:20%" title="Click a name to edit player details">Player Name</th>
                            <th style="width:13%" title="Player's phone number for text messages">Phone</th>
                            <th style="width:12%" id="thCarrier">Carrier</th>
                            <th style="width:9%" title="FargoRate skill rating - yellow highlight means missing">Fargo</th>
                            <th style="width:8%" id="thSidePot" title="Check to enter player in optional side pot">Side Pot</th>
                            <th style="width:7%" title="Check when player has paid entry fee">Paid</th>
                            <th style="width:6%" title="Check if player is running late but confirmed coming">Late</th>
                            <th style="width:7%"></th>
                        </tr>
                    </thead>
                    <tbody id="playerTableBody">
                        <!-- Rows added dynamically -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- Payouts Display -->
        <div class="card">
            <div class="card-header">
                <span>üí∞ Tournament Payouts</span>
                <span id="payoutTotal">$0 Prize Pool</span>
            </div>
            <div class="payouts-grid" id="payoutsDisplay">
                <div class="payout-placeholder">Add 4+ paid players to see payouts</div>
            </div>
        </div>
    </div>
    
            <!-- Side Pot Tab -->
            <div class="tab-content" id="tab-sidepot">
        <div class="summary-grid-4">
            <div class="summary-card">
                <div class="summary-value" id="sidepotPlayers">0</div>
                <div class="summary-label">Players In</div>
            </div>
            <div class="summary-card secondary">
                <div class="summary-value" id="sidepotTotal">$0</div>
                <div class="summary-label">Side Pot Total</div>
            </div>
            <div class="summary-card" style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);">
                <div class="summary-value" id="sidepotPlacesPaid">0</div>
                <div class="summary-label">Places Paid</div>
                <div id="sidepotPayoutsList" style="font-size: 0.85rem; margin-top: 8px; text-align: left;"></div>
            </div>
            <div class="summary-card" style="background: linear-gradient(135deg, #059669 0%, #047857 100%); cursor: pointer;" onclick="openSidepotPayoutsModal()">
                <div class="summary-value" style="font-size: 1.5rem;">‚öôÔ∏è</div>
                <div class="summary-label">Edit Payouts</div>
            </div>
        </div>
        
        <div class="card">
            <div class="card-header">
                <span>Side Pot Entry</span>
                <span>$<span id="sidepotAmountDisplay">5</span> per player</span>
            </div>
            <div class="player-list" id="sidepotPlayerList">
                <div class="loading">
                    <div class="spinner"></div>
                    Loading players...
                </div>
            </div>
        </div>
    </div>
    
    <!-- Calcutta Tab -->
    <div class="tab-content" id="tab-calcutta">
        <div class="summary-grid-4">
            <div class="summary-card" title="Sum of all Calcutta auction bids">
                <div class="summary-value" id="calcuttaTotal">$0</div>
                <div class="summary-label">Total Bids</div>
            </div>
            <div class="summary-card warning" title="Total Calcutta bids not yet collected">
                <div class="summary-value" id="calcuttaUnpaid">$0</div>
                <div class="summary-label">Unpaid</div>
            </div>
        </div>
        
        <div class="card">
            <div class="card-header">
                <span>Calcutta Auction</span>
            </div>
            
            <!-- Start Calcutta Button -->
            <div class="start-calcutta-container" id="startCalcuttaContainer">
                <button class="start-calcutta-btn" id="startCalcuttaBtn" onclick="toggleCalcuttaActive()">
                    üéØ Start Calcutta
                </button>
                <div class="calcutta-status-text" id="calcuttaStatusText">
                    Click to start the live auction display
                </div>
            </div>
            
            <div class="card-body" id="calcuttaBody">
                <div class="sort-controls">
                    <span style="align-self: center; margin-right: 10px;">Sort by:</span>
                    <button class="sort-btn" onclick="sortCalcutta('order')" id="sortOrder">Check-in Order</button>
                    <button class="sort-btn" onclick="sortCalcutta('name')" id="sortName">Name</button>
                    <button class="sort-btn active" onclick="sortCalcutta('skill')" id="sortSkill">Skill Level ‚Üì</button>
                    <button class="sort-btn" onclick="sortCalcutta('bid')" id="sortBid">Bid Amount ‚Üì</button>
                </div>
                <div style="overflow-x: auto;">
                    <table class="calcutta-table" id="calcuttaTable">
                        <thead>
                            <tr>
                                <th style="width:28%">Player</th>
                                <th style="width:12%">Skill</th>
                                <th style="width:8%" title="Check if player bought themselves">Self</th>
                                <th style="width:32%" title="Enter the name of who purchased this player">Buyer</th>
                                <th style="width:20%" title="Enter the winning bid amount">Bid</th>
                            </tr>
                        </thead>
                        <tbody id="calcuttaTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Buyers Tab -->
    <div class="tab-content" id="tab-buyers">
        <div class="summary-grid-4">
            <div class="summary-card">
                <div class="summary-value" id="totalBuyers">0</div>
                <div class="summary-label">Total Buyers</div>
            </div>
            <div class="summary-card secondary">
                <div class="summary-value" id="totalOwed">$0</div>
                <div class="summary-label">Total Owed</div>
            </div>
            <div class="summary-card warning">
                <div class="summary-value" id="unpaidBuyers">0</div>
                <div class="summary-label">Unpaid</div>
            </div>
            <div class="summary-card" style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);">
                <div class="summary-value" id="calcuttaPlacesPaid">0</div>
                <div class="summary-label">Places Paid</div>
                <div class="calcutta-payouts-list" id="calcuttaPayoutsList" style="font-size: 0.85rem; margin-top: 8px; text-align: left;"></div>
            </div>
        </div>
        
        <div class="card">
            <div class="card-header">
                <span>Buyer Summary</span>
                <button class="btn btn-small btn-success" onclick="markAllPaid()">Mark All Paid</button>
            </div>
            <div class="buyer-summary" id="buyerSummaryList">
            </div>
        </div>
    </div>
        </main>
    </div>
    
    <!-- Add New Player Modal -->
    <div class="modal-overlay" id="addPlayerModal">
        <div class="modal">
            <div class="modal-header">
                <span>Add New Player to Database</span>
                <button class="modal-close" onclick="closeModal('addPlayerModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Full Name *</label>
                    <input type="text" class="form-control" id="addPlayerModalName" placeholder="Enter full name">
                </div>
                <div class="form-group">
                    <label>Phone Number</label>
                    <input type="tel" class="form-control" id="addPlayerModalPhone" placeholder="(xxx) xxx-xxxx">
                </div>
                <div class="form-group">
                    <label>Mobile Carrier</label>
                    <select class="form-control" id="addPlayerModalCarrier">
                        <option value="">-- Select Carrier --</option>
                        <option value="verizon">Verizon</option>
                        <option value="att">AT&T</option>
                        <option value="tmobile">T-Mobile</option>
                        <option value="sprint">Sprint</option>
                        <option value="uscellular">US Cellular</option>
                        <option value="cricket">Cricket</option>
                        <option value="metropcs">Metro PCS</option>
                        <option value="boost">Boost Mobile</option>
                        <option value="virgin">Virgin Mobile</option>
                        <option value="googlefi">Google Fi</option>
                        <option value="xfinity">Xfinity Mobile</option>
                        <option value="spectrum">Spectrum Mobile</option>
                        <option value="consumer_cellular">Consumer Cellular</option>
                        <option value="mint">Mint Mobile</option>
                        <option value="visible">Visible</option>
                        <option value="straight_talk">Straight Talk</option>
                        <option value="other">Other / Unknown</option>
                    </select>
                    <small style="color:var(--text-light);">Used for MMS messaging</small>
                </div>
                <p style="color:var(--text-light);font-size:0.9rem;margin-top:10px;">
                    üìä After adding, you'll be able to link to FargoRate for skill rating
                </p>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('addPlayerModal')">Cancel</button>
                <button class="btn btn-success" onclick="saveNewPlayer()">Next: Find on FargoRate</button>
            </div>
        </div>
    </div>
    
    <!-- FargoRate Selection Modal -->
    <div class="modal-overlay" id="fargoModal">
        <div class="modal">
            <div class="modal-header">
                <span>Select Player from FargoRate</span>
                <button class="modal-close" onclick="closeModal('fargoModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Search FargoRate</label>
                    <div style="display:flex;gap:10px;">
                        <input type="text" class="form-control" id="fargoSearchInput" 
                               placeholder="Enter name to search...">
                        <button class="btn btn-primary" onclick="searchFargo()">Search</button>
                    </div>
                    <small style="color:var(--text-light);">Tip: Try first initial + last name (e.g., "M Chambers")</small>
                </div>
                <div id="fargoResults" class="fargo-results">
                    <div class="loading" style="display:none;" id="fargoLoading">
                        <div class="spinner"></div>
                        Searching FargoRate...
                    </div>
                    <div id="fargoResultsList"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="skipFargoSelection()">Skip (No FargoRate)</button>
            </div>
        </div>
    </div>
    
    <!-- Name Confirmation Modal -->
    <div class="modal-overlay" id="nameConfirmModal">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <span>Confirm Player Name</span>
                <button class="modal-close" onclick="closeModal('nameConfirmModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div style="text-align:center; margin-bottom: 20px;">
                    <p style="font-size: 1.1rem; margin-bottom: 15px;">Is this name spelled correctly in FargoRate?</p>
                    <div style="background: var(--bg-light); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <div style="font-size: 1.4rem; font-weight: 700; color: var(--primary);" id="confirmFargoName">-</div>
                        <div style="font-size: 1rem; color: var(--text-light);">Fargo Rating: <span id="confirmFargoRating">-</span></div>
                    </div>
                    <div style="background: #fef3c7; padding: 10px; border-radius: 6px; font-size: 0.9rem; color: #92400e;">
                        <strong>Your database name:</strong> <span id="confirmLocalName">-</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="flex-direction: column; gap: 10px;">
                <button class="btn btn-success" onclick="confirmFargoNameCorrect()" style="width: 100%;">
                    ‚úì Yes, FargoRate name is correct - update my database
                </button>
                <button class="btn btn-primary" onclick="confirmFargoNameCorrect(true)" style="width: 100%;">
                    ‚úì Use my database name (keep as-is)
                </button>
                <button class="btn" onclick="reportFargoNameIssue()" style="width: 100%; background: #dc2626; color: white;">
                    ‚úó FargoRate name is wrong - report to FargoRate
                </button>
            </div>
        </div>
    </div>
    
    <!-- Edit Phone Modal -->
    <div class="modal-overlay" id="editPhoneModal">
        <div class="modal">
            <div class="modal-header">
                <span>Edit Phone Number</span>
                <button class="modal-close" onclick="closeModal('editPhoneModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Player</label>
                    <input type="text" class="form-control" id="editPhonePlayerName" readonly>
                </div>
                <div class="form-group">
                    <label>Phone Number</label>
                    <input type="tel" class="form-control" id="editPhoneNumber" placeholder="(xxx) xxx-xxxx">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('editPhoneModal')">Cancel</button>
                <button class="btn btn-success" onclick="savePhoneUpdate()">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Edit Player Modal -->
    <div class="modal-overlay" id="editPlayerModal">
        <div class="modal">
            <div class="modal-header">
                <span>Edit Player Record</span>
                <button class="modal-close" onclick="closeModal('editPlayerModal')">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="editPlayerOriginalName">
                <input type="hidden" id="editPlayerId">
                <div class="form-group">
                    <label>Full Name</label>
                    <input type="text" class="form-control" id="editPlayerName" placeholder="Player name">
                </div>
                <div class="form-group">
                    <label>Phone Number</label>
                    <input type="tel" class="form-control" id="editPlayerPhone" placeholder="(xxx) xxx-xxxx">
                </div>
                <div class="form-group">
                    <label>Mobile Carrier</label>
                    <select class="form-control" id="editPlayerCarrier">
                        <option value="">-- Select Carrier --</option>
                        <option value="verizon">Verizon</option>
                        <option value="att">AT&T</option>
                        <option value="tmobile">T-Mobile</option>
                        <option value="sprint">Sprint</option>
                        <option value="uscellular">US Cellular</option>
                        <option value="cricket">Cricket</option>
                        <option value="metropcs">Metro PCS</option>
                        <option value="boost">Boost Mobile</option>
                        <option value="virgin">Virgin Mobile</option>
                        <option value="googlefi">Google Fi</option>
                        <option value="xfinity">Xfinity Mobile</option>
                        <option value="spectrum">Spectrum Mobile</option>
                        <option value="consumer_cellular">Consumer Cellular</option>
                        <option value="mint">Mint Mobile</option>
                        <option value="visible">Visible</option>
                        <option value="straight_talk">Straight Talk</option>
                        <option value="other">Other / Unknown</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Fargo Rating</label>
                    <div style="display:flex; gap:10px;">
                        <input type="number" class="form-control" id="editPlayerSkill" placeholder="Rating" min="0" max="900" style="width:100px;">
                        <button class="btn btn-primary" onclick="lookupFargoForEdit()" style="white-space:nowrap;">üîç Lookup</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('editPlayerModal')">Cancel</button>
                <button class="btn btn-success" onclick="savePlayerEdit()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Sidepot Payouts Modal -->
    <div class="modal-overlay" id="sidepotPayoutsModal">
        <div class="modal">
            <div class="modal-header">
                <span>Edit Side Pot Payouts</span>
                <button class="modal-close" onclick="closeModal('sidepotPayoutsModal')">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 15px; color: var(--text-light);">Enter payout amounts for each place. Leave blank for places that don't pay.</p>
                <div id="sidepotPayoutsInputs" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;"></div>
                <button class="btn btn-primary" onclick="addSidepotPayoutRow()" style="margin-top: 15px; width: 100%;">+ Add Place</button>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('sidepotPayoutsModal')">Cancel</button>
                <button class="btn btn-success" onclick="saveSidepotPayouts()">Save Payouts</button>
            </div>
        </div>
    </div>
    
    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <script>
    // ============================================================================
    // STATE MANAGEMENT
    // ============================================================================
    
    // Determine default entry fee based on day of week
    function getDefaultEntryFee() {
        const dayOfWeek = new Date().getDay(); // 0=Sun, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat
        // Friday (5) and Saturday (6) = $20, Monday (1) and Wednesday (3) = $15
        if (dayOfWeek === 5 || dayOfWeek === 6) {
            return 20;
        }
        return 15; // Default for Mon, Wed, and other days
    }
    
    const state = {
        eventType: '', // 'recurring' or 'special'
        selectedTournament: '', // Selected tournament name for special events
        upcomingTournaments: [], // List of upcoming tournaments
        masterPlayers: [], // All players from master database
        preregisteredPlayers: [], // For special events
        checkedInPlayers: [], // Currently checked in
        settings: {
            entryFee: getDefaultEntryFee(),
            sidepotAmount: 5,
            addedMoney: 0,
            sidepotPayouts: [],
            showSkillLevel: true
        },
        tournamentSettings: {
            playerAuction: true,
            sidepot: true,
            entryFee: null
        },
        calcuttaSort: 'skill',
        editingPlayerId: null,
        pendingNewPlayer: null, // For FargoRate selection flow
        activeAutocompleteRow: null, // Track which row has autocomplete open
        poolAuction: {
            buyer: '',
            bid: 0,
            paid: false
        },
        calcuttaActive: false
    };
    
    // ============================================================================
    // PAYOUT CALCULATOR (Exact port from tournament_payout_calculator.php)
    // ============================================================================
    
    class TournamentPayoutCalculator {
        constructor(entryFee, numPlayers, addedMoney = 0) {
            this.entryFee = entryFee;
            this.numPlayers = numPlayers;
            this.addedMoney = addedMoney;
            this.totalPrizePool = (entryFee * numPlayers) + addedMoney;
            
            [this.baseEntryFee, this.multiplier] = this.determineBaseAndMultiplier(entryFee);
        }
        
        determineBaseAndMultiplier(entryFee) {
            if (entryFee % 10 === 5) {
                return [5, entryFee / 5];
            }
            if (entryFee % 10 === 0) {
                const tens = (entryFee / 10) % 2;
                if (tens === 1) {
                    return [10, entryFee / 10];
                } else {
                    return [20, entryFee / 20];
                }
            }
            return [entryFee, 1];
        }
        
        roundAmount(amount) {
            let rounded = Math.round(amount / this.baseEntryFee) * this.baseEntryFee;
            if (rounded < this.entryFee) {
                rounded = this.entryFee;
            }
            return rounded;
        }
        
        getMaxPlaceToPay() {
            const n = this.numPlayers;
            if (n < 4) return 0;
            if (n >= 4 && n < 8) return 1;      // 4-7 players: 1st only
            if (n >= 8 && n < 12) return 2;     // 8-11 players: 1st-2nd
            if (n >= 12 && n < 16) return 3;    // 12-15 players: 1st-3rd
            if (n >= 16 && n < 24) return 4;    // 16-23 players: 1st-4th
            if (n >= 24 && n < 32) return 6;    // 24-31 players: 1st-6th
            if (n >= 32 && n < 48) return 8;    // 32-47 players: 1st-8th
            if (n >= 48 && n < 64) return 12;   // 48-63 players: 1st-12th
            if (n >= 64 && n < 96) return 16;   // 64-95 players: 1st-16th
            if (n >= 96 && n < 128) return 24;  // 96-127 players: 1st-24th
            if (n >= 128 && n < 192) return 32; // 128-191 players: 1st-32nd
            if (n >= 192 && n < 256) return 48; // 192-255 players: 1st-48th
            if (n >= 256) return 64;            // 256+ players: 1st-64th
            return 0;
        }
        
        getTieGroups() {
            const maxPlace = this.getMaxPlaceToPay();
            if (maxPlace === 0) return [];
            
            const groups = [];
            
            // Standard tie structure for all tournaments
            if (maxPlace >= 1) groups.push({start: 1, end: 1});
            if (maxPlace >= 2) groups.push({start: 2, end: 2});
            if (maxPlace >= 3) groups.push({start: 3, end: 3});
            if (maxPlace >= 4) groups.push({start: 4, end: 4});
            if (maxPlace >= 6) groups.push({start: 5, end: 6});
            if (maxPlace >= 8) groups.push({start: 7, end: 8});
            if (maxPlace >= 12) groups.push({start: 9, end: 12});
            if (maxPlace >= 16) groups.push({start: 13, end: 16});
            if (maxPlace >= 24) groups.push({start: 17, end: 24});
            if (maxPlace >= 32) groups.push({start: 25, end: 32});
            if (maxPlace >= 48) groups.push({start: 33, end: 48});
            if (maxPlace >= 64) groups.push({start: 49, end: 64});
            
            return groups;
        }
        
        calculatePayouts() {
            const groups = this.getTieGroups();
            
            if (groups.length === 0) {
                return {error: "Minimum 4 players required"};
            }
            
            const maxPlace = groups[groups.length - 1].end;
            const numGroups = groups.length;
            
            // Special case: Only 1st place (4-7 players)
            if (maxPlace === 1) {
                return { 1: this.totalPrizePool };
            }
            
            // Special case: 1st and 2nd place (8-11 players)
            if (maxPlace === 2) {
                const payouts = {};
                payouts[1] = this.roundAmount(this.totalPrizePool * 0.65);
                payouts[2] = this.totalPrizePool - payouts[1];
                return payouts;
            }
            
            // Special case: 1st, 2nd, 3rd (12-15 players)
            if (maxPlace === 3) {
                const payouts = {};
                payouts[1] = this.roundAmount(this.totalPrizePool * 0.50);
                payouts[2] = this.roundAmount(this.totalPrizePool * 0.30);
                payouts[3] = this.totalPrizePool - payouts[1] - payouts[2];
                return payouts;
            }
            
            // Special case: 4 places (16-23 players) gets direct percentages
            if (maxPlace === 4) {
                // Reference: 55%, 25%, 15%, 5% for 1st, 2nd, 3rd, 4th
                const payouts = {};
                payouts[1] = this.roundAmount(this.totalPrizePool * 0.55);
                payouts[2] = this.roundAmount(this.totalPrizePool * 0.25);
                payouts[3] = this.roundAmount(this.totalPrizePool * 0.15);
                payouts[4] = this.entryFee; // Last place = entry fee exactly
                
                // Balance adjustment
                const total = Object.values(payouts).reduce((a, b) => a + b, 0);
                payouts[1] += (this.totalPrizePool - total);
                
                return payouts;
            }
            
            // For all other cases, use baseline + bonus model
            const baselinePot = this.entryFee * maxPlace;
            const bonusPot = this.totalPrizePool - baselinePot;
            
            // Calculate bonus weights with VERY AGGRESSIVE decay (0.45-0.5)
            const weights = [];
            let totalWeight = 0;
            const decayRate = (numGroups > 6) ? 0.45 : 0.5;
            
            for (let i = 0; i < numGroups; i++) {
                const weight = Math.pow(decayRate, i);
                weights[i] = weight;
                totalWeight += weight;
            }
            
            // Distribute bonuses
            let payouts = {};
            
            groups.forEach((group, i) => {
                const groupSize = group.end - group.start + 1;
                const bonusShare = (weights[i] / totalWeight) * bonusPot;
                const bonusPerPlace = bonusShare / groupSize;
                
                const totalPayout = this.entryFee + bonusPerPlace;
                const rounded = this.roundAmount(totalPayout);
                
                for (let place = group.start; place <= group.end; place++) {
                    payouts[place] = rounded;
                }
            });
            
            // Enforce descending order
            for (let i = 1; i < numGroups; i++) {
                const currentGroup = groups[i];
                const previousGroup = groups[i - 1];
                
                const currentAmount = payouts[currentGroup.start];
                const previousAmount = payouts[previousGroup.start];
                
                if (currentAmount >= previousAmount) {
                    let newAmount = previousAmount - this.baseEntryFee;
                    if (newAmount < this.entryFee) {
                        newAmount = this.entryFee;
                    }
                    
                    for (let place = currentGroup.start; place <= currentGroup.end; place++) {
                        payouts[place] = newAmount;
                    }
                }
            }
            
            // Dynamic cutoff - remove places that don't have distinct payouts
            const groupPayouts = [];
            groups.forEach((group, i) => {
                groupPayouts[i] = payouts[group.start];
            });
            
            let cutoffGroupIndex = groups.length - 1;
            
            for (let i = 1; i < groupPayouts.length; i++) {
                if (groupPayouts[i] >= groupPayouts[i - 1]) {
                    cutoffGroupIndex = i - 1;
                    break;
                }
            }
            
            const cutoffPlace = groups[cutoffGroupIndex].end;
            const filteredPayouts = {};
            Object.keys(payouts).forEach(place => {
                if (parseInt(place) <= cutoffPlace) {
                    filteredPayouts[place] = payouts[place];
                }
            });
            payouts = filteredPayouts;
            
            // AGGRESSIVE STRATEGY: Try to make last place = entry fee exactly
            const lastPlace = Math.max(...Object.keys(payouts).map(Number));
            if (payouts[lastPlace] > this.entryFee) {
                // Calculate how much we can reclaim from last place
                const reclaimable = payouts[lastPlace] - this.entryFee;
                payouts[lastPlace] = this.entryFee;
                
                // Redistribute to earlier places, weighted toward first
                const recipientPlaces = [];
                const recipientWeights = {};
                let totalRecipientWeight = 0;
                
                Object.keys(payouts).forEach(place => {
                    const p = parseInt(place);
                    if (p < lastPlace) {
                        const weight = Math.pow(0.6, p - 1); // Earlier places get more
                        recipientPlaces.push(p);
                        recipientWeights[p] = weight;
                        totalRecipientWeight += weight;
                    }
                });
                
                // Distribute the reclaimed money
                recipientPlaces.forEach(place => {
                    const share = (recipientWeights[place] / totalRecipientWeight) * reclaimable;
                    payouts[place] += share;
                });
            }
            
            // Final balance adjustment
            let allocatedTotal = Object.values(payouts).reduce((a, b) => a + b, 0);
            let difference = this.totalPrizePool - allocatedTotal;
            payouts[1] += difference;
            
            // Ensure first place is at least 15% more than second
            if (payouts[2]) {
                const minFirst = payouts[2] * 1.15;
                if (payouts[1] < minFirst) {
                    const needed = minFirst - payouts[1];
                    payouts[1] = minFirst;
                    
                    let otherTotal = 0;
                    Object.keys(payouts).forEach(place => {
                        if (parseInt(place) > 1) otherTotal += payouts[place];
                    });
                    
                    if (otherTotal > needed) {
                        Object.keys(payouts).forEach(place => {
                            if (parseInt(place) > 1) {
                                payouts[place] -= (payouts[place] / otherTotal) * needed;
                            }
                        });
                    }
                }
            }
            
            // FINAL: Round all payouts to smart denominations
            Object.keys(payouts).forEach(place => {
                payouts[place] = this.roundAmount(payouts[place]);
            });
            
            // One more balance check after rounding
            const finalTotal = Object.values(payouts).reduce((a, b) => a + b, 0);
            if (Math.abs(finalTotal - this.totalPrizePool) > 0.01) {
                payouts[1] += (this.totalPrizePool - finalTotal);
            }
            
            // Sort by place number
            const sortedPayouts = {};
            Object.keys(payouts).map(Number).sort((a, b) => a - b).forEach(place => {
                sortedPayouts[place] = payouts[place];
            });
            
            return sortedPayouts;
        }
        
        getFormattedPayouts() {
            const payouts = this.calculatePayouts();
            if (payouts.error) return payouts;
            
            const formatted = {};
            const labels = {
                1: '1st', 2: '2nd', 3: '3rd', 4: '4th',
                5: '5th-6th', 6: '5th-6th',
                7: '7th-8th', 8: '7th-8th',
                9: '9th-12th', 10: '9th-12th', 11: '9th-12th', 12: '9th-12th',
                13: '13th-16th', 14: '13th-16th', 15: '13th-16th', 16: '13th-16th',
                17: '17th-24th', 18: '17th-24th', 19: '17th-24th', 20: '17th-24th',
                21: '17th-24th', 22: '17th-24th', 23: '17th-24th', 24: '17th-24th',
                25: '25th-32nd', 26: '25th-32nd', 27: '25th-32nd', 28: '25th-32nd',
                29: '25th-32nd', 30: '25th-32nd', 31: '25th-32nd', 32: '25th-32nd'
            };
            
            Object.keys(payouts).forEach(place => {
                const label = labels[place] || `${place}th`;
                if (!formatted[label]) {
                    formatted[label] = payouts[place];
                }
            });
            
            return formatted;
        }
    }

    // ============================================================================
    // CALCUTTA PAYOUT CALCULATOR (Based on TournamentPayoutCalculator methodology)
    // Pays ~10% of field, rounds to $5, uses aggressive bonus model
    // ============================================================================

    class CalcuttaPayoutCalculator {
        constructor(totalPot, numPlayers) {
            this.totalPot = totalPot;
            this.numPlayers = numPlayers;
            this.baseAmount = 5;
        }

        roundAmount(amount) {
            let rounded = Math.round(amount / this.baseAmount) * this.baseAmount;
            if (rounded < this.baseAmount) rounded = this.baseAmount;
            return rounded;
        }

        getMaxPlaceToPay() {
            const n = this.numPlayers;
            if (n < 10) return 1;
            if (n >= 10 && n < 20) return 2;
            if (n >= 20 && n < 30) return 3;
            if (n >= 30 && n < 40) return 4;
            if (n >= 40 && n < 60) return 6;
            if (n >= 60 && n < 80) return 8;
            if (n >= 80 && n < 120) return 12;
            if (n >= 120 && n < 160) return 16;
            if (n >= 160) return 24;
            return 1;
        }

        getTieGroups() {
            const maxPlace = this.getMaxPlaceToPay();
            if (maxPlace === 0) return [];
            const groups = [];
            if (maxPlace >= 1) groups.push({start: 1, end: 1});
            if (maxPlace >= 2) groups.push({start: 2, end: 2});
            if (maxPlace >= 3) groups.push({start: 3, end: 3});
            if (maxPlace >= 4) groups.push({start: 4, end: 4});
            if (maxPlace >= 6) groups.push({start: 5, end: 6});
            if (maxPlace >= 8) groups.push({start: 7, end: 8});
            if (maxPlace >= 12) groups.push({start: 9, end: 12});
            if (maxPlace >= 16) groups.push({start: 13, end: 16});
            if (maxPlace >= 24) groups.push({start: 17, end: 24});
            return groups;
        }

        calculatePayouts() {
            const groups = this.getTieGroups();
            if (groups.length === 0 || this.totalPot < this.baseAmount) return { error: "Not enough data" };
            const maxPlace = groups[groups.length - 1].end;
            const numGroups = groups.length;

            if (maxPlace === 1) return { 1: this.totalPot };

            if (maxPlace === 2) {
                const payouts = {};
                payouts[1] = this.roundAmount(this.totalPot * 0.65);
                payouts[2] = this.totalPot - payouts[1];
                return payouts;
            }

            if (maxPlace === 3) {
                const payouts = {};
                payouts[1] = this.roundAmount(this.totalPot * 0.50);
                payouts[2] = this.roundAmount(this.totalPot * 0.30);
                payouts[3] = this.totalPot - payouts[1] - payouts[2];
                return payouts;
            }

            if (maxPlace === 4) {
                const payouts = {};
                payouts[1] = this.roundAmount(this.totalPot * 0.50);
                payouts[2] = this.roundAmount(this.totalPot * 0.25);
                payouts[3] = this.roundAmount(this.totalPot * 0.15);
                payouts[4] = this.roundAmount(this.totalPot * 0.10);
                const total = Object.values(payouts).reduce((a, b) => a + b, 0);
                payouts[1] += (this.totalPot - total);
                return payouts;
            }

            const minPayout = this.baseAmount;
            const baselinePot = minPayout * maxPlace;
            const bonusPot = this.totalPot - baselinePot;

            if (bonusPot <= 0) {
                const perPlace = this.roundAmount(this.totalPot / maxPlace);
                const payouts = {};
                for (let i = 1; i <= maxPlace; i++) payouts[i] = perPlace;
                return payouts;
            }

            const weights = [];
            let totalWeight = 0;
            const decayRate = (numGroups > 6) ? 0.45 : 0.5;
            for (let i = 0; i < numGroups; i++) {
                const weight = Math.pow(decayRate, i);
                weights[i] = weight;
                totalWeight += weight;
            }

            const payouts = {};
            groups.forEach((group, i) => {
                const groupSize = group.end - group.start + 1;
                const bonusShare = (weights[i] / totalWeight) * bonusPot;
                const bonusPerPlace = bonusShare / groupSize;
                const totalPayout = minPayout + bonusPerPlace;
                const rounded = this.roundAmount(totalPayout);
                for (let place = group.start; place <= group.end; place++) payouts[place] = rounded;
            });

            for (let i = 1; i < numGroups; i++) {
                const currentGroup = groups[i];
                const previousGroup = groups[i - 1];
                const currentAmount = payouts[currentGroup.start];
                const previousAmount = payouts[previousGroup.start];
                if (currentAmount >= previousAmount) {
                    const newAmount = Math.max(previousAmount - this.baseAmount, this.baseAmount);
                    for (let place = currentGroup.start; place <= currentGroup.end; place++) payouts[place] = newAmount;
                }
            }

            const allocatedTotal = Object.values(payouts).reduce((a, b) => a + b, 0);
            payouts[1] += (this.totalPot - allocatedTotal);
            return payouts;
        }

        getFormattedPayouts() {
            const payouts = this.calculatePayouts();
            if (payouts.error) return { placesToPay: 0, payouts: [] };
            const groups = this.getTieGroups();
            const formatted = [];
            groups.forEach(group => {
                const amount = payouts[group.start];
                let label;
                if (group.start === group.end) {
                    label = this.getPlaceLabel(group.start);
                } else {
                    label = this.getPlaceLabel(group.start) + "-" + this.getPlaceLabel(group.end).replace(/[a-z]+$/, "");
                }
                formatted.push({ place: label, amount: amount });
            });
            return { placesToPay: this.getMaxPlaceToPay(), payouts: formatted };
        }

        getPlaceLabel(place) {
            if (place === 1) return "1st";
            if (place === 2) return "2nd";
            if (place === 3) return "3rd";
            if (place === 4) return "4th";
            if (place === 5) return "5th";
            if (place === 6) return "6th";
            if (place === 7) return "7th";
            if (place === 8) return "8th";
            if (place === 9) return "9th";
            if (place === 12) return "12th";
            if (place === 16) return "16th";
            if (place === 24) return "24th";
            return place + "th";
        }
    }
    
    // ============================================================================
    // FARGORATE API
    // ============================================================================
    
    const FARGO_API_URL = 'https://dashboard.fargorate.com/api/indexsearch';
    
    // ============================================================================
    // GOOGLE APPS SCRIPT URL - UPDATE THIS AFTER DEPLOYMENT
    // ============================================================================
    
    const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbzQ5_5LzmudZ15JjAXguaL3HU0ZxeQKNRO0n--kbOZ3DkbapCoh4NvVQWwqQwwVZ-kRLg/exec';
    
// GitHub Actions Workflow Configuration
// Token is now stored securely server-side in trigger_workflow.php
const GITHUB_CONFIG = {
    triggerEndpoint: '/trigger_workflow.php'
};
    
    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    
    document.addEventListener('DOMContentLoaded', () => {
        // Set initial entry fee based on day of week
        const entryFeeInput = document.getElementById('entryFeeInput');
        const dayIndicator = document.getElementById('dayIndicator');
        
        if (entryFeeInput) {
            entryFeeInput.value = getDefaultEntryFee();
        }
        
        // Show day indicator
        if (dayIndicator) {
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const dayOfWeek = new Date().getDay();
            const dayName = days[dayOfWeek];
            const fee = getDefaultEntryFee();
            dayIndicator.textContent = `(${dayName} = $${fee})`;
        }
        
        // Close autocomplete dropdowns on scroll
        document.querySelector('.spreadsheet-container')?.addEventListener('scroll', () => {
            const list = document.getElementById('inlineAutocompleteList');
            if (list) list.classList.remove('show');
        });
        
        // Close autocomplete on click outside
        document.addEventListener('click', (e) => {
            const list = document.getElementById('inlineAutocompleteList');
            const input = document.getElementById('newPlayerInput');
            if (list && input && !list.contains(e.target) && e.target !== input) {
                list.classList.remove('show');
                list.style.display = 'none';
            }
        });
        
        loadFromLocalStorage();
        updateAllDisplays();
        updateCalcuttaActiveUI();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
        
        // Always load master players from API on startup if not already loaded
        if (APPS_SCRIPT_URL && state.masterPlayers.length === 0) {
            console.log('No master players in cache, loading from API...');
            loadMasterPlayers();
        } else {
            console.log('Loaded', state.masterPlayers.length, 'players from cache');
        }
    });
    
    function loadFromLocalStorage() {
        const saved = localStorage.getItem('tournamentConsoleState');
        if (saved) {
            const parsed = JSON.parse(saved);
            Object.assign(state, parsed);
            
            // Migrate 'weekly' to 'recurring' for backwards compatibility
            if (state.eventType === 'weekly') {
                state.eventType = 'recurring';
            }
            
            // Ensure poolAuction exists (for backwards compatibility)
            if (!state.poolAuction) {
                state.poolAuction = { buyer: '', bid: 0, paid: false };
            }
            
            // Ensure new tournament fields exist
            if (!state.upcomingTournaments) {
                state.upcomingTournaments = [];
            }
            if (!state.selectedTournament) {
                state.selectedTournament = '';
            }
            
            // Ensure tournament settings exist
            if (!state.tournamentSettings) {
                state.tournamentSettings = {
                    playerAuction: true,
                    sidepot: true,
                    entryFee: null
                };
            }
            
            // Restore settings inputs
            const entryFeeInput = document.getElementById('entryFeeInput');
            const sidepotInput = document.getElementById('sidepotInput');
            const showSkillLevel = document.getElementById('showSkillLevel');
            
            if (entryFeeInput) entryFeeInput.value = state.settings.entryFee;
            if (sidepotInput) sidepotInput.value = state.settings.sidepotAmount;
            const addedMoneyInput = document.getElementById('addedMoneyInput');
            if (addedMoneyInput) addedMoneyInput.value = state.settings.addedMoney || 0;
            if (showSkillLevel) showSkillLevel.checked = state.settings.showSkillLevel;
            
            // Apply tournament settings (tabs enable/disable)
            applyTournamentSettings();
            
            // Restore event type selection
            if (state.eventType) {
                selectEventType(state.eventType);
                
                // If special event with selected tournament, render the list and reselect
                if (state.eventType === 'special' && state.selectedTournament) {
                    if (state.upcomingTournaments.length > 0) {
                        renderTournamentList();
                    }
                    document.getElementById('headerInfo').textContent = `${state.selectedTournament} - ${state.checkedInPlayers?.length || 0} checked in`;
                }
                    document.getElementById('tournamentNameDisplay').textContent = state.selectedTournament;
            }
        }
        
        // Initialize displays
        updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
    }
    
    function saveToLocalStorage() {
        localStorage.setItem('tournamentConsoleState', JSON.stringify(state));
        
        // Also save tournament-specific data
        saveTournamentData();
    }
    
    // ============================================================================
    // TOURNAMENT-SPECIFIC DATA STORAGE
    // ============================================================================
    
    // Generate a unique storage key for the current tournament
    function getTournamentStorageKey() {
        if (state.eventType === 'special' && state.selectedTournament) {
            // Use tournament name for special events
            return 'tournamentData_' + state.selectedTournament.replace(/[^a-zA-Z0-9]/g, '_');
        } else if (state.eventType === 'recurring') {
            // Use today's date for recurring tournaments
            const today = new Date().toISOString().split('T')[0];
            return 'tournamentData_recurring_' + today;
        }
        return null;
    }
    
    // Save current tournament's data separately
    function saveTournamentData() {
        const key = getTournamentStorageKey();
        if (!key) return;
        
        const tournamentData = {
            checkedInPlayers: state.checkedInPlayers,
            poolAuction: state.poolAuction,
            settings: {
                entryFee: state.settings.entryFee,
                sidepotAmount: state.settings.sidepotAmount,
                addedMoney: state.settings.addedMoney || 0,
                sidepotPayouts: state.settings.sidepotPayouts || []
            },
            tournamentSettings: state.tournamentSettings,
            calcuttaActive: state.calcuttaActive,
            savedAt: new Date().toISOString()
        };
        
        localStorage.setItem(key, JSON.stringify(tournamentData));
        console.log('Saved tournament data to:', key);
        syncToServer();
    }
    
    // Load tournament-specific data (returns true if data was found)
    // Sync tournament data to server for TV displays (calcutta.html, sidepot.html)
    function syncToServer() {
        const key = getTournamentStorageKey();
        if (!key) return;
        
        let tournamentName = '';
        if (state.eventType === 'special' && state.selectedTournament) {
            tournamentName = state.selectedTournament;
        } else if (state.eventType === 'recurring') {
            tournamentName = localStorage.getItem('currentTournamentName') || 'Weekly Tournament';
        }
        
        const tournamentData = {
            tournamentKey: key,
            tournamentName: tournamentName,
            eventType: state.eventType,
            checkedInPlayers: state.checkedInPlayers,
            poolAuction: state.poolAuction,
            settings: {
                entryFee: state.settings.entryFee,
                sidepotAmount: state.settings.sidepotAmount,
                addedMoney: state.settings.addedMoney || 0,
                sidepotPayouts: state.settings.sidepotPayouts || []
            },
            tournamentSettings: state.tournamentSettings,
            calcuttaActive: state.calcuttaActive
        };
        
        fetch('/save_tournament.php', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(tournamentData)
        })
        .then(response => response.json())
        .then(result => {
            if (!result.success) console.error('Server sync failed:', result.error);
        })
        .catch(error => console.error('Server sync error:', error));
    }

    function loadTournamentData() {
        const key = getTournamentStorageKey();
        if (!key) return false;
        
        const saved = localStorage.getItem(key);
        if (saved) {
            try {
                const data = JSON.parse(saved);
                state.checkedInPlayers = data.checkedInPlayers || [];
                state.poolAuction = data.poolAuction || { buyer: '', bid: 0, paid: false };
                
                // Restore settings
                if (data.settings) {
                    state.settings.entryFee = data.settings.entryFee || state.settings.entryFee;
                    state.settings.sidepotAmount = data.settings.sidepotAmount || state.settings.sidepotAmount;
                    state.settings.addedMoney = data.settings.addedMoney || 0;
                    state.settings.sidepotPayouts = data.settings.sidepotPayouts || [];
                    
                    // Update UI
                    const entryFeeInput = document.getElementById('entryFeeInput');
                    if (entryFeeInput) entryFeeInput.value = state.settings.entryFee;
                    const addedMoneyInput = document.getElementById('addedMoneyInput');
                    if (addedMoneyInput) addedMoneyInput.value = state.settings.addedMoney || 0;
                }
                
                if (data.tournamentSettings) {
                    state.tournamentSettings = data.tournamentSettings;
                }
                
                // Load calcutta active state
                state.calcuttaActive = data.calcuttaActive || false;
                
                console.log('Loaded tournament data from:', key, '- Players:', state.checkedInPlayers.length);
                
                // Update calcutta UI after loading
                setTimeout(() => updateCalcuttaActiveUI(), 100);
                
                return true;
            } catch (e) {
                console.error('Error loading tournament data:', e);
                return false;
            }
        }
        return false;
    }
    
    // Clear tournament data (for starting fresh)
    function clearTournamentData() {
        const key = getTournamentStorageKey();
        if (key) {
            localStorage.removeItem(key);
            console.log('Cleared tournament data:', key);
        }
    }
    
    // List all saved tournaments (for debugging)
    window.listSavedTournaments = function() {
        const tournaments = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith('tournamentData_')) {
                const data = JSON.parse(localStorage.getItem(key));
                tournaments.push({
                    key: key,
                    players: data.checkedInPlayers?.length || 0,
                    savedAt: data.savedAt
                });
            }
        }
        console.table(tournaments);
        return tournaments;
    };
    
    // ============================================================================
    // EVENT TYPE HANDLING
    // ============================================================================
    
    function selectEventType(eventType) {
        const previousEventType = state.eventType;
        
        // Save current tournament data before switching event types
        if (previousEventType && (previousEventType !== eventType)) {
            saveTournamentData();
        }
        
        state.eventType = eventType;
        
        // Update button states
        document.getElementById('btnRecurring').classList.remove('active');
        document.getElementById('btnSpecial').classList.remove('active');
        
        const tournamentListDiv = document.getElementById('tournamentList');
        
        if (eventType === 'special') {
            document.getElementById('btnSpecial').classList.add('active');
            
            // Clear state for special events (will be loaded when tournament is selected)
            state.selectedTournament = '';
            state.checkedInPlayers = [];
            state.poolAuction = { buyer: '', bid: 0, paid: false };
            
            // Show tournament list
            tournamentListDiv.style.display = 'block';
            document.getElementById('headerInfo').textContent = 'Select a tournament...';
            loadUpcomingTournaments();
        } else if (eventType === 'recurring') {
            document.getElementById('btnRecurring').classList.add('active');
            
            // Hide tournament list
            tournamentListDiv.style.display = 'none';
            
            // Fetch tournament name from Digital Pool scraper data
            fetchDigitalPoolTournamentName();
            
            // Reset tournament settings for recurring mode (enable all features)
            state.tournamentSettings = {
                playerAuction: true,
                sidepot: true,
                entryFee: null
            };
            
            // Try to load saved recurring tournament data for today
            state.selectedTournament = '';
            const hasSavedData = loadTournamentData();
            
            if (hasSavedData) {
                showToast(`Restored ${state.checkedInPlayers.length} players from today's tournament`, 'success');
            } else {
                // Reset for fresh tournament
                state.checkedInPlayers = [];
                state.poolAuction = { buyer: '', bid: 0, paid: false };
                state.settings.entryFee = getDefaultEntryFee();
            }
            
            const entryFeeInput = document.getElementById('entryFeeInput');
            if (entryFeeInput) {
                entryFeeInput.value = state.settings.entryFee;
            }
            
            applyTournamentSettings();
            loadMasterPlayers();
        }
        
        updateAllDisplays();

        saveToLocalStorage();
    }
    
    async function fetchDigitalPoolTournamentName() {
        try {
            const response = await fetch('/tournament_data.json');
            if (response.ok) {
                const data = await response.json();
                if (data.tournament_name) {
                    let cleanName = data.tournament_name.replace(/^\d{4}\/\d{1,2}\/\d{1,2}\s+/, '');
                    localStorage.setItem('currentTournamentName', cleanName);
                    console.log('Tournament name:', cleanName);
                    document.getElementById('headerInfo').textContent = cleanName;
                    document.getElementById('tournamentNameDisplay').textContent = cleanName;
                }
            }
        } catch (error) {
            console.error('Error fetching tournament data:', error);
        }
    }

    async function autoDetectTodaysTournament() {
        // Prevent multiple runs
        if (window.tournamentAutoDetected) return;
        window.tournamentAutoDetected = true;
        try {
            const response = await fetch('/tournament_data.json');
            if (response.ok) {
                const data = await response.json();
                
                // Check if there's a tournament for today - MUST verify date matches!
                const today = new Date();
                const todayStr = today.getFullYear() + '/' + 
                    String(today.getMonth() + 1).padStart(2, '0') + '/' + 
                    String(today.getDate()).padStart(2, '0');
                
                const tournamentDateMatches = data.date === todayStr;
                
                if (!tournamentDateMatches && data.date) {
                    console.log('Tournament date mismatch - JSON has:', data.date, 'but today is:', todayStr);
                }
                
                if (data.tournament_name && data.display_tournament && tournamentDateMatches) {
                    // Clean the name (remove date prefix)
                    let cleanName = data.tournament_name.replace(/^\d{4}\/\d{1,2}\/\d{1,2}\s+/, '');
                    
                    // Store for calcutta/sidepot pages
                    localStorage.setItem('currentTournamentName', cleanName);
                    
                    // Auto-select recurring mode
                    state.eventType = 'recurring';
                    document.getElementById('btnRecurring').classList.add('active');
                    document.getElementById('btnSpecial').classList.remove('active');
                    document.getElementById('tournamentList').style.display = 'none';
                    document.getElementById('headerInfo').textContent = cleanName;
                    document.getElementById('headerInfo').textContent = cleanName;
                    const banner = document.getElementById('tournamentNameDisplay'); if (banner) banner.textContent = cleanName;
                    // Load recurring tournament settings
                    state.tournamentSettings = {
                        playerAuction: true,
                        sidepot: true,
                        entryFee: data.entry_fee || null
                    };
                    
                    if (data.entry_fee) {
                        state.settings.entryFee = data.entry_fee;
                        const entryFeeInput = document.getElementById('entryFeeInput');
                        if (entryFeeInput) entryFeeInput.value = data.entry_fee;
                    }
                    
                    // Try to load saved data for today
                    state.selectedTournament = '';
                    loadTournamentData();
                    
                    applyTournamentSettings();
                    
                    console.log('Auto-detected tournament:', cleanName);
                }
            }
        } catch (error) {
            console.log('No tournament auto-detected:', error.message);
        }
    }

    // Legacy function for backward compatibility
    function handleEventTypeChange() {
        const select = document.getElementById('eventType');
        if (select) {
            const value = select.value;
            if (value === 'weekly') selectEventType('recurring');
            else if (value === 'special') selectEventType('special');
        }
    }
    
    // Load upcoming tournaments and render as list
    async function loadUpcomingTournaments() {
        const listContainer = document.getElementById('tournamentListItems');
        listContainer.innerHTML = '<div class="tournament-loading">Loading tournaments...</div>';
        
        try {
            if (!APPS_SCRIPT_URL) {
                throw new Error('API not configured');
            }
            
            const response = await fetch(APPS_SCRIPT_URL + '?action=getUpcomingTournaments');
            const data = await response.json();
            
            if (data.error) {
                throw new Error(data.error);
            }
            
            state.upcomingTournaments = data.tournaments || [];
            
            // Render tournament list
            renderTournamentList();
            
            document.getElementById('headerInfo').textContent = `${state.upcomingTournaments.length} tournaments available`;
            
        } catch (error) {
            console.error('Error loading tournaments:', error);
            listContainer.innerHTML = '<div class="tournament-loading" style="color:#f87171;">Error loading tournaments</div>';
            document.getElementById('headerInfo').textContent = 'Error loading tournaments';
            showToast('Error loading tournaments: ' + error.message, 'error');
        }
    }
    
    // Render tournament list in sidebar
    function renderTournamentList() {
        const listContainer = document.getElementById('tournamentListItems');
        
        if (state.upcomingTournaments.length === 0) {
            listContainer.innerHTML = '<div class="tournament-loading">No upcoming tournaments</div>';
            return;
        }
        
        let html = '';
        state.upcomingTournaments.forEach(tournament => {
            const isActive = state.selectedTournament === tournament.name;
            html += `
                <div class="tournament-item ${isActive ? 'active' : ''}" onclick="selectTournament('${escapeForJs(tournament.name)}')">
                    <div class="tournament-item-name">${escapeHtml(tournament.name)}</div>
                    ${tournament.date ? `<div class="tournament-item-date">${tournament.date}</div>` : ''}
                </div>
            `;
        });
        
        listContainer.innerHTML = html;
    }
    
    // Select a tournament from the list
    async function selectTournament(tournamentName) {
        // Save previous tournament data
        if (state.selectedTournament && state.selectedTournament !== tournamentName) {
            saveTournamentData();
            state.checkedInPlayers = [];
            state.poolAuction = { buyer: '', bid: 0, paid: false };
        } else if (state.selectedTournament === tournamentName) {
            // Same tournament - save current state before refresh
            saveTournamentData();
        }
        
        state.selectedTournament = tournamentName;
        
        // Update UI to show selection
        renderTournamentList();
        document.getElementById('headerInfo').textContent = 'Loading ' + tournamentName + '...';
        document.getElementById('tournamentNameDisplay').textContent = tournamentName;
        
        // Load the tournament data
        await loadTournamentRegistrationsForName(tournamentName);
    }
    
    // Load registrations for selected tournament (legacy wrapper)
    async function loadTournamentRegistrations() {
        const tournamentSelect = document.getElementById('tournamentSelect');
        if (tournamentSelect && tournamentSelect.value) {
            await loadTournamentRegistrationsForName(tournamentSelect.value);
        }
    }
    
    // Load registrations for a specific tournament by name
    async function loadTournamentRegistrationsForName(tournamentName) {
        if (!tournamentName) {
            // Save current tournament data before deselecting
            saveTournamentData();
            
            state.selectedTournament = '';
            state.preregisteredPlayers = [];
            state.masterPlayers = [];
            document.getElementById('headerInfo').textContent = 'Select a tournament...';
            updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
            saveToLocalStorage();
            return;
        }
        
        state.selectedTournament = tournamentName;
        document.getElementById('headerInfo').textContent = 'Loading registrations...';
        
        try {
            if (!APPS_SCRIPT_URL) {
                throw new Error('API not configured');
            }
            
            const response = await fetch(APPS_SCRIPT_URL + '?action=getTournamentRegistrations&tournament=' + encodeURIComponent(tournamentName));
            const data = await response.json();
            
            if (data.error) {
                throw new Error(data.error);
            }
            
            state.preregisteredPlayers = data.players || [];
            state.masterPlayers = state.preregisteredPlayers;
            
            // Apply tournament settings first
            if (data.settings) {
                state.tournamentSettings = {
                    playerAuction: data.settings.playerAuction !== false,
                    sidepot: data.settings.sidepot !== false,
                    entryFee: data.settings.entryFee
                };
                
                // Update entry fee if provided (but may be overridden by saved data)
                if (data.settings.entryFee) {
                    state.settings.entryFee = data.settings.entryFee;
                }
                
                console.log('Tournament settings from API:', state.tournamentSettings);
            }
            
            // Try to load saved tournament data
            const hasSavedData = loadTournamentData();
            
            if (hasSavedData) {
                // Sync with registration sheet: handle adds, removes, and updates
                const registrationNames = state.preregisteredPlayers.map(p => p.name.toLowerCase().trim());
                const checkedInNames = state.checkedInPlayers.map(p => p.name.toLowerCase().trim());
                
                // 1. REMOVE: Players no longer in registration sheet
                const removedPlayers = state.checkedInPlayers.filter(p => 
                    !registrationNames.includes(p.name.toLowerCase().trim())
                );
                if (removedPlayers.length > 0) {
                    state.checkedInPlayers = state.checkedInPlayers.filter(p => 
                        registrationNames.includes(p.name.toLowerCase().trim())
                    );
                    console.log('Removed players no longer in registration:', removedPlayers.map(p => p.name));
                }
                
                // 2. UPDATE: Sync data for existing players (skill rating, phone, team members)
                state.checkedInPlayers.forEach(checkedIn => {
                    const registration = state.preregisteredPlayers.find(p => 
                        p.name.toLowerCase().trim() === checkedIn.name.toLowerCase().trim()
                    );
                    if (registration) {
                        // Update fields that come from registration (preserve local fields like hasPaid, calcuttaBuyer, etc.)
                        checkedIn.skill = registration.skill;
                        checkedIn.phone = registration.phone || checkedIn.phone;
                        checkedIn.isTeam = registration.isTeam;
                        checkedIn.playerCount = registration.playerCount;
                        checkedIn.teamName = registration.teamName;
                    }
                });
                
                // 3. ADD: New registrants not yet checked in
                const newRegistrants = state.preregisteredPlayers.filter(player => 
                    !checkedInNames.includes(player.name.toLowerCase().trim())
                );
                
                if (newRegistrants.length > 0) {
                    const newCheckedIn = newRegistrants.map((player, index) => ({
                        ...player,
                        id: Date.now() + index,
                        originalId: player.id,
                        checkedInAt: new Date().toISOString(),
                        hasPaid: false,
                        inSidePot: false,
                        isLate: false,
                        carrier: player.carrier || '',
                        calcuttaBuyer: '',
                        calcuttaBid: 0,
                        calcuttaPaid: false,
                        isSpecialEvent: true,
                        isTeam: player.isTeam || false,
                        playerCount: player.playerCount || 1
                    }));
                    
                    state.checkedInPlayers = [...state.checkedInPlayers, ...newCheckedIn];
                }
                
                // Show summary of changes
                const changes = [];
                if (removedPlayers.length > 0) changes.push(`${removedPlayers.length} removed`);
                if (newRegistrants.length > 0) changes.push(`${newRegistrants.length} added`);
                
                if (changes.length > 0) {
                    showToast(`Synced: ${changes.join(', ')}. ${state.checkedInPlayers.length} total.`, 'success');
                } else {
                    showToast(`${state.checkedInPlayers.length} players synced`, 'success');
                }
            } else {
                // No saved data - auto-check in all registrants
                state.checkedInPlayers = state.preregisteredPlayers.map((player, index) => ({
                    ...player,
                    id: Date.now() + index,
                    originalId: player.id,
                    checkedInAt: new Date().toISOString(),
                    hasPaid: false,
                    inSidePot: false,
                    isLate: false,
                    carrier: player.carrier || '',
                    calcuttaBuyer: '',
                    calcuttaBid: 0,
                    calcuttaPaid: false,
                    isSpecialEvent: true,
                    isTeam: player.isTeam || false,
                    playerCount: player.playerCount || 1
                }));
                showToast(`Auto-checked in ${state.checkedInPlayers.length} registrants`, 'success');
            }
            
            document.getElementById('headerInfo').textContent = `${tournamentName} - ${state.checkedInPlayers.length} checked in`;
            
            // Update entry fee UI
            const entryFeeInput = document.getElementById('entryFeeInput');
            if (entryFeeInput) {
                entryFeeInput.value = state.settings.entryFee;
            }
            
            // Update UI based on tournament settings
            applyTournamentSettings();
            
            updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
            
        } catch (error) {
            console.error('Error loading registrations:', error);
            document.getElementById('headerInfo').textContent = `${tournamentName} - Error loading registrations`;
            showToast('Error loading registrations: ' + error.message, 'error');
        }
        
        saveToLocalStorage();
    }
    
    // Apply tournament settings to UI
    function applyTournamentSettings() {
        const isSpecialEvent = state.eventType === 'special';
        
        // Handle logo vs QR code
        const sidebarLogo = document.getElementById('sidebarLogo');
        const sidebarQR = document.getElementById('sidebarQR');
        if (sidebarLogo && sidebarQR) {
            if (isSpecialEvent) {
                sidebarLogo.style.display = 'none';
                sidebarQR.style.display = 'block';
            } else {
                sidebarLogo.style.display = 'block';
                sidebarQR.style.display = 'none';
            }
        }
        
        // Handle Add Player vs Add Registration button
        const btnAddPlayer = document.getElementById('btnAddPlayer');
        const btnAddRegistration = document.getElementById('btnAddRegistration');
        if (btnAddPlayer && btnAddRegistration) {
            if (isSpecialEvent) {
                btnAddPlayer.style.display = 'none';
                btnAddRegistration.style.display = 'block';
            } else {
                btnAddPlayer.style.display = 'block';
                btnAddRegistration.style.display = 'none';
            }
        }
        
        // Handle Calcutta/Auction tab - HIDE if no player auction for special events
        const calcuttaTab = document.querySelector('.sidebar-tab[data-tab="calcutta"]');
        if (calcuttaTab) {
            if (isSpecialEvent && !state.tournamentSettings.playerAuction) {
                calcuttaTab.style.display = 'none';
            } else {
                calcuttaTab.style.display = 'flex';
            }
        }
        
        // Handle Buyers tab - HIDE if no player auction for special events
        const buyersTab = document.querySelector('.sidebar-tab[data-tab="buyers"]');
        if (buyersTab) {
            if (isSpecialEvent && !state.tournamentSettings.playerAuction) {
                buyersTab.style.display = 'none';
            } else {
                buyersTab.style.display = 'flex';
            }
        }
        
        // Handle Side Pot tab - HIDE if no sidepot for special events
        const sidepotTab = document.querySelector('.sidebar-tab[data-tab="sidepot"]');
        if (sidepotTab) {
            if (isSpecialEvent && !state.tournamentSettings.sidepot) {
                sidepotTab.style.display = 'none';
            } else {
                sidepotTab.style.display = 'flex';
            }
        }
        
        // Handle Side Pot setting in sidebar - HIDE if no sidepot for special events
        const sidepotSetting = document.getElementById('sidepotSetting');
        if (sidepotSetting) {
            if (isSpecialEvent && !state.tournamentSettings.sidepot) {
                sidepotSetting.style.display = 'none';
            } else {
                sidepotSetting.style.display = 'flex';
            }
        }
        
        // Handle Added Money setting - SHOW only for special events
        const addedMoneySetting = document.getElementById('addedMoneySetting');
        if (addedMoneySetting) {
            addedMoneySetting.style.display = isSpecialEvent ? 'flex' : 'none';
        }
        
        // Handle Player Database link - HIDE for special events (only useful for recurring)
        const btnPlayerDB = document.getElementById('btnPlayerDB');
        if (btnPlayerDB) {
            btnPlayerDB.style.display = isSpecialEvent ? 'none' : 'block';
        }
    }
    
    // ============================================================================
    // DATA LOADING
    // ============================================================================
    
    async function loadMasterPlayers() {
        console.log('loadMasterPlayers() called...');
        
        try {
            // Try to load from Google Apps Script API
            if (APPS_SCRIPT_URL) {
                console.log('Fetching from API:', APPS_SCRIPT_URL + '?action=getMasterPlayers');
                const response = await fetch(APPS_SCRIPT_URL + '?action=getMasterPlayers');
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                state.masterPlayers = data.players || [];
                
                // Debug: Log comprehensive info
                console.log('========================================');
                console.log('LOADED PLAYERS FROM API:', state.masterPlayers.length);
                console.log('========================================');
                
                if (state.masterPlayers.length > 0) {
                    console.log('First 5 players:');
                    state.masterPlayers.slice(0, 5).forEach((p, i) => {
                        console.log(`  ${i+1}. ${p.name}`);
                        console.log(`      phone: "${p.phone}" (${p.phone ? '‚úì HAS PHONE' : '‚úó NO PHONE'})`);
                        console.log(`      skill: ${p.skill || 'none'}`);
                    });
                    
                    // Look for specific players
                    const testNames = ['Aaron Muncy', 'Tom Carlisle', 'Jason Bertolo', 'Michael D Chambers'];
                    console.log('\nSearching for specific players:');
                    testNames.forEach(name => {
                        const found = state.masterPlayers.find(p => 
                            p.name.toLowerCase().includes(name.toLowerCase())
                        );
                        if (found) {
                            console.log(`  ‚úì Found "${found.name}": phone="${found.phone}", id=${found.id}`);
                        } else {
                            console.log(`  ‚úó NOT FOUND: "${name}"`);
                        }
                    });
                }
                console.log('========================================');
                
                showToast(`Loaded ${state.masterPlayers.length} players from database`, 'success');
            } else {
                // Fallback to sample data for demo/offline mode
                state.masterPlayers = getSampleMasterPlayers();
                showToast('Using sample data (configure API URL for live data)', 'info');
            }
            
            saveToLocalStorage();
            updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
        } catch (error) {
            console.error('Error loading master players:', error);
            // Fallback to sample data
            state.masterPlayers = getSampleMasterPlayers();
            showToast('Using offline mode: ' + error.message, 'error');
            updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
        }
    }
    
    // Note: loadSpecialEventData() removed - replaced with loadTournamentRegistrations()
    
    function refreshData() {
        // Clear cached master players to force fresh load
        state.masterPlayers = [];
        
        if (state.eventType === 'special') {
            // For special events, reload tournaments and re-select
            loadUpcomingTournaments().then(() => {
                if (state.selectedTournament) {
                    loadTournamentRegistrations();
                }
            });
        } else {
            loadMasterPlayers();
        }
    }
    
    // Force clear all cached data and reload
    async function forceRefreshFromAPI() {
        console.log('Force refreshing from API...');
        
        // Preserve current tournament data (checked-in players, etc.)
        const checkedIn = state.checkedInPlayers || [];
        const settings = state.settings;
        const poolAuction = state.poolAuction;
        const eventType = state.eventType;
        const selectedTournament = state.selectedTournament;
        
        // Clear master players cache
        state.masterPlayers = [];
        
        // Load fresh from API
        try {
            showToast('Loading players from database...', 'info');
            
            if (eventType === 'special' && selectedTournament) {
                // For special events, reload tournament registrations
                const response = await fetch(APPS_SCRIPT_URL + '?action=getTournamentRegistrations&tournament=' + encodeURIComponent(selectedTournament));
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                state.preregisteredPlayers = data.players || [];
                state.masterPlayers = state.preregisteredPlayers;
                
                // Sync with registration sheet: handle adds, removes, and updates
                const registrationNames = state.preregisteredPlayers.map(p => p.name.toLowerCase().trim());
                const checkedInNames = checkedIn.map(p => p.name.toLowerCase().trim());
                
                // 1. REMOVE: Players no longer in registration sheet
                const keptPlayers = checkedIn.filter(p => 
                    registrationNames.includes(p.name.toLowerCase().trim())
                );
                const removedCount = checkedIn.length - keptPlayers.length;
                
                // 2. UPDATE: Sync data for existing players
                keptPlayers.forEach(player => {
                    const registration = state.preregisteredPlayers.find(p => 
                        p.name.toLowerCase().trim() === player.name.toLowerCase().trim()
                    );
                    if (registration) {
                        player.skill = registration.skill;
                        player.phone = registration.phone || player.phone;
                        player.isTeam = registration.isTeam;
                        player.playerCount = registration.playerCount;
                        player.teamName = registration.teamName;
                    }
                });
                
                // 3. ADD: New registrants
                const newRegistrants = state.preregisteredPlayers.filter(player => 
                    !checkedInNames.includes(player.name.toLowerCase().trim())
                );
                
                const newCheckedIn = newRegistrants.map((player, index) => ({
                    ...player,
                    id: Date.now() + index,
                    originalId: player.id,
                    checkedInAt: new Date().toISOString(),
                    hasPaid: false,
                    inSidePot: false,
                    isLate: false,
                    carrier: player.carrier || '',
                    calcuttaBuyer: '',
                    calcuttaBid: 0,
                    calcuttaPaid: false,
                    isSpecialEvent: true,
                    isTeam: player.isTeam || false,
                    playerCount: player.playerCount || 1
                }));
                
                state.checkedInPlayers = [...keptPlayers, ...newCheckedIn];
                
                // Show summary
                const changes = [];
                if (removedCount > 0) changes.push(`${removedCount} removed`);
                if (newRegistrants.length > 0) changes.push(`${newRegistrants.length} added`);
                if (changes.length > 0) {
                    showToast(`Synced: ${changes.join(', ')}. ${state.checkedInPlayers.length} total.`, 'success');
                } else {
                    showToast(`${state.checkedInPlayers.length} players synced`, 'success');
                }
                
            } else {
                // For recurring events, load master players
                const response = await fetch(APPS_SCRIPT_URL + '?action=getMasterPlayers');
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                state.masterPlayers = data.players || [];
                
                // Restore tournament state for recurring
                state.checkedInPlayers = checkedIn;
                showToast(`Loaded ${state.masterPlayers.length} players from database`, 'success');
            }
            
            // Restore other state
            state.settings = settings;
            state.poolAuction = poolAuction;
            state.eventType = eventType;
            state.selectedTournament = selectedTournament;
            
            console.log('========================================');
            console.log('FORCE RELOAD - Loaded', state.masterPlayers.length, 'players');
            console.log('========================================');
            
            if (state.masterPlayers.length > 0) {
                console.log('Sample players:');
                state.masterPlayers.slice(0, 3).forEach(p => {
                    console.log(`  - ${p.name}: phone="${p.phone}"`);
                });
            }
            
            saveToLocalStorage();
            updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
            
        } catch (error) {
            console.error('Force refresh failed:', error);
            showToast('Error loading: ' + error.message, 'error');
        }
    }
    
    // ============================================================================
    // SAMPLE DATA (Replace with actual API calls)
    // ============================================================================
    
    function getSampleMasterPlayers() {
        return [
            { id: 1, name: 'John Smith', phone: '614-555-0101', skill: 523, fargoId: 'ABC12345' },
            { id: 2, name: 'Mike Johnson', phone: '614-555-0102', skill: 612, fargoId: 'DEF67890' },
            { id: 3, name: 'Sarah Williams', phone: '614-555-0103', skill: 445, fargoId: 'GHI11111' },
            { id: 4, name: 'David Brown', phone: '614-555-0104', skill: 701, fargoId: 'JKL22222' },
            { id: 5, name: 'Emily Davis', phone: '614-555-0105', skill: 389, fargoId: null },
            { id: 6, name: 'Chris Miller', phone: '614-555-0106', skill: 756, fargoId: 'MNO33333' },
            { id: 7, name: 'Jessica Wilson', phone: '614-555-0107', skill: 534, fargoId: 'PQR44444' },
            { id: 8, name: 'Robert Taylor', phone: '614-555-0108', skill: 628, fargoId: 'STU55555' },
            { id: 9, name: 'Amanda Martinez', phone: '614-555-0109', skill: 412, fargoId: null },
            { id: 10, name: 'Kevin Anderson', phone: '614-555-0110', skill: 825, fargoId: 'VWX66666' },
        ];
    }
    
    function getSamplePreregistrationData() {
        return [
            { id: 1, name: 'Tournament Player 1', phone: '614-555-0201', skill: 678, fargoId: 'PRE11111', preregistered: true },
            { id: 2, name: 'Tournament Player 2', phone: '614-555-0202', skill: 542, fargoId: 'PRE22222', preregistered: true },
            { id: 3, name: 'Tournament Player 3', phone: '614-555-0203', skill: 789, fargoId: 'PRE33333', preregistered: true },
            { id: 4, name: 'Tournament Player 4', phone: '614-555-0204', skill: 623, fargoId: null, preregistered: true },
            { id: 5, name: 'Tournament Player 5', phone: '614-555-0205', skill: 445, fargoId: 'PRE44444', preregistered: true },
        ];
    }
    
    // ============================================================================
    // AUTOCOMPLETE
    // ============================================================================
    
    let autocompleteIndex = -1;
    
    function handlePlayerSearch(query) {
        const list = document.getElementById('autocompleteList');
        
        if (query.length < 2) {
            list.classList.remove('show');
            return;
        }
        
        const matches = state.masterPlayers.filter(p => 
            p.name.toLowerCase().includes(query.toLowerCase()) &&
            !state.checkedInPlayers.find(cp => cp.id === p.id)
        ).slice(0, 10);
        
        if (matches.length === 0) {
            list.classList.remove('show');
            return;
        }
        
        list.innerHTML = matches.map((p, i) => `
            <div class="autocomplete-item ${i === autocompleteIndex ? 'selected' : ''}" 
                 onclick="selectPlayer(${p.id})">
                <div class="name">${highlightMatch(p.name, query)}</div>
                <div class="phone">${p.phone || 'No phone'}</div>
            </div>
        `).join('');
        
        list.classList.add('show');
        autocompleteIndex = -1;
    }
    
    function highlightMatch(text, query) {
        const regex = new RegExp(`(${query})`, 'gi');
        return text.replace(regex, '<strong>$1</strong>');
    }
    
    function handleAutocompleteKeydown(event) {
        const list = document.getElementById('autocompleteList');
        const items = list.querySelectorAll('.autocomplete-item');
        
        if (event.key === 'ArrowDown') {
            event.preventDefault();
            autocompleteIndex = Math.min(autocompleteIndex + 1, items.length - 1);
            updateAutocompleteSelection(items);
        } else if (event.key === 'ArrowUp') {
            event.preventDefault();
            autocompleteIndex = Math.max(autocompleteIndex - 1, 0);
            updateAutocompleteSelection(items);
        } else if (event.key === 'Enter') {
            event.preventDefault();
            if (autocompleteIndex >= 0 && items[autocompleteIndex]) {
                items[autocompleteIndex].click();
            } else {
                addPlayer();
            }
        } else if (event.key === 'Escape') {
            list.classList.remove('show');
        }
    }
    
    function updateAutocompleteSelection(items) {
        items.forEach((item, i) => {
            item.classList.toggle('selected', i === autocompleteIndex);
        });
    }
    
    function selectPlayer(playerId) {
        const player = state.masterPlayers.find(p => p.id === playerId);
        if (player) {
            document.getElementById('playerNameInput').value = player.name;
            document.getElementById('playerPhoneInput').value = player.phone || '';
            document.getElementById('autocompleteList').classList.remove('show');
        }
    }
    
    // ============================================================================
    // PLAYER MANAGEMENT
    // ============================================================================
    
    function addPlayer() {
        const nameInput = document.getElementById('playerNameInput');
        const phoneInput = document.getElementById('playerPhoneInput');
        
        const name = nameInput.value.trim();
        const phone = phoneInput.value.trim();
        
        if (!name) {
            showToast('Please enter a player name', 'error');
            return;
        }
        
        // Check if already checked in
        if (state.checkedInPlayers.find(p => p.name.toLowerCase() === name.toLowerCase())) {
            showToast('Player already checked in', 'error');
            return;
        }
        
        // Find in master list or create new
        let player = state.masterPlayers.find(p => p.name.toLowerCase() === name.toLowerCase());
        
        if (player) {
            // Update phone if provided and different
            if (phone && phone !== player.phone) {
                player.phone = phone;
            }
        } else {
            // New player
            player = {
                id: Date.now(),
                name: name,
                phone: phone,
                skill: null,
                isNew: true
            };
            state.masterPlayers.push(player);
        }
        
        // Add to checked in
        state.checkedInPlayers.push({
            ...player,
            checkedInAt: new Date().toISOString(),
            inSidePot: false,
            calcuttaBuyer: '',
            calcuttaBid: 0,
            calcuttaPaid: false
        });
        
        // Clear inputs
        nameInput.value = '';
        phoneInput.value = '';
        document.getElementById('autocompleteList').classList.remove('show');
        
        showToast(`${name} checked in`, 'success');
        saveToLocalStorage();
        updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
    }
    
    function removePlayer(playerId) {
        if (confirm('Remove this player from check-in?')) {
            state.checkedInPlayers = state.checkedInPlayers.filter(p => p.id !== playerId);
            saveToLocalStorage();
            updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
            showToast('Player removed', 'success');
        }
    }
    
    function showAddNewPlayerModal() {
        const nameInput = document.getElementById('addPlayerModalName');
        const phoneInput = document.getElementById('addPlayerModalPhone');
        const carrierInput = document.getElementById('addPlayerModalCarrier');
        const modal = document.getElementById('addPlayerModal');
        
        if (nameInput) nameInput.value = '';
        if (phoneInput) phoneInput.value = '';
        if (carrierInput) carrierInput.value = '';
        if (modal) modal.classList.add('show');
    }
    
    async function saveNewPlayer() {
        const name = document.getElementById('addPlayerModalName').value.trim();
        const phone = document.getElementById('addPlayerModalPhone').value.trim();
        const carrier = document.getElementById('addPlayerModalCarrier').value;
        
        if (!name) {
            showToast('Please enter a name', 'error');
            return;
        }
        
        // Store pending player info for FargoRate flow
        state.pendingNewPlayer = {
            name: name,
            phone: phone,
            carrier: carrier,
            hasPaid: false, // Default to unpaid
            inSidePot: false
        };
        
        closeModal('addPlayerModal');
        
        // Pre-populate search with name
        document.getElementById('fargoSearchInput').value = name;
        document.getElementById('fargoResultsList').innerHTML = '';
        document.getElementById('fargoModal').classList.add('show');
        
        // Auto-search with the name
        searchFargo();
    }
    
    // Old addPlayer function for backwards compatibility
    function addPlayer() {
        const nameInput = document.getElementById('playerNameInput');
        const phoneInput = document.getElementById('playerPhoneInput');
        
        if (!nameInput || !phoneInput) return;
        
        const name = nameInput.value.trim();
        const phone = phoneInput.value.trim();
        
        if (!name) {
            showToast('Please enter a player name', 'error');
            return;
        }
        
        // Check if already checked in
        if (state.checkedInPlayers.find(p => p.name.toLowerCase() === name.toLowerCase())) {
            showToast('Player already checked in', 'error');
            return;
        }
        
        // Find in master list or trigger FargoRate lookup
        let player = state.masterPlayers.find(p => p.name.toLowerCase() === name.toLowerCase());
        
        if (player) {
            // Update phone if provided and different
            if (phone && phone !== player.phone) {
                player.phone = phone;
            }
            
            // Add to checked in
            state.checkedInPlayers.push({
                ...player,
                id: Date.now(),
                originalId: player.id,
                checkedInAt: new Date().toISOString(),
                hasPaid: false, // Default to unpaid
                inSidePot: false,
                calcuttaBuyer: '',
                calcuttaBid: 0,
                calcuttaPaid: false
            });
            
            nameInput.value = '';
            phoneInput.value = '';
            
            showToast(`${name} checked in`, 'success');
            saveToLocalStorage();
            updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
        } else {
            // New player - trigger FargoRate lookup
            addNewPlayerQuick(name);
        }
    }
    
    // ============================================================================
    // FARGORATE INTEGRATION
    // ============================================================================
    
    async function searchFargo() {
        const query = document.getElementById('fargoSearchInput').value.trim();
        if (!query) {
            showToast('Enter a name to search', 'error');
            return;
        }
        
        const loading = document.getElementById('fargoLoading');
        const resultsList = document.getElementById('fargoResultsList');
        
        loading.style.display = 'block';
        resultsList.innerHTML = '';
        
        try {
            const response = await fetch(FARGO_API_URL + '?q=' + encodeURIComponent(query));
            const data = await response.json();
            
            loading.style.display = 'none';
            
            if (!data.value || data.value.length === 0) {
                resultsList.innerHTML = `
                    <div class="no-results">
                        <p>No players found for "${query}"</p>
                        <p style="font-size:0.9rem;">Try using first initial + last name (e.g., "M Chambers")</p>
                    </div>
                `;
                return;
            }
            
            // Display results using correct API structure
            resultsList.innerHTML = data.value.slice(0, 10).map(player => {
                // Get Fargo ID prefix (first segment of UUID)
                const fargoIdPrefix = player.id ? player.id.split('-')[0] : '';
                
                // Combine firstName and lastName
                const playerName = `${player.firstName || ''} ${player.lastName || ''}`.trim() || 'Unknown';
                
                // Location is already combined in API response
                const location = player.location ? player.location.trim() : '';
                
                // Use effectiveRating (current rating) or fall back to rating
                const rating = player.effectiveRating || player.rating || 0;
                
                return `
                    <div class="fargo-result-item" onclick="selectFargoPlayer('${fargoIdPrefix}', '${escapeHtml(playerName)}', ${rating})">
                        <div class="fargo-info">
                            <div class="fargo-name">${escapeHtml(playerName)}</div>
                            <div class="fargo-location">${location || 'Location unknown'}</div>
                        </div>
                        <div class="fargo-rating">${rating}</div>
                    </div>
                `;
            }).join('');
            
        } catch (error) {
            loading.style.display = 'none';
            console.error('FargoRate search error:', error);
            resultsList.innerHTML = `
                <div class="no-results">
                    <p>Error searching FargoRate</p>
                    <p style="font-size:0.9rem;">${error.message}</p>
                </div>
            `;
        }
    }
    
    // Store pending Fargo selection for confirmation
    let pendingFargoSelection = null;
    
    function selectFargoPlayer(fargoIdPrefix, fargoName, fargoRating) {
        if (!state.pendingNewPlayer) {
            showToast('Error: No pending player', 'error');
            closeModal('fargoModal');
            return;
        }
        
        // Store the selection for confirmation
        pendingFargoSelection = {
            fargoId: fargoIdPrefix,
            fargoName: fargoName,
            fargoRating: fargoRating,
            localName: state.pendingNewPlayer.name
        };
        
        // Show confirmation modal
        document.getElementById('confirmFargoName').textContent = fargoName;
        document.getElementById('confirmFargoRating').textContent = fargoRating;
        document.getElementById('confirmLocalName').textContent = state.pendingNewPlayer.name;
        
        closeModal('fargoModal');
        document.getElementById('nameConfirmModal').classList.add('show');
    }
    
    function confirmFargoNameCorrect(useLocalName = false) {
        if (!pendingFargoSelection || !state.pendingNewPlayer) {
            closeModal('nameConfirmModal');
            return;
        }
        
        const { fargoId, fargoName, fargoRating, localName } = pendingFargoSelection;
        
        // Determine which name to use
        const nameToUse = useLocalName ? localName : fargoName;
        const shouldUpdateName = !useLocalName && fargoName !== localName;
        
        // Check if this is linking an existing player or adding a new one
        if (state.pendingNewPlayer.existingPlayerId) {
            // Update existing player
            const playerId = state.pendingNewPlayer.existingPlayerId;
            
            const checkedInPlayer = state.checkedInPlayers.find(p => p.id === playerId);
            if (checkedInPlayer) {
                checkedInPlayer.fargoId = fargoId;
                checkedInPlayer.fargoName = fargoName;
                checkedInPlayer.skill = fargoRating;
                if (shouldUpdateName) {
                    checkedInPlayer.name = fargoName;
                }
            }
            
            const masterPlayer = state.masterPlayers.find(p => p.id === playerId);
            if (masterPlayer) {
                masterPlayer.fargoId = fargoId;
                masterPlayer.fargoName = fargoName;
                masterPlayer.skill = fargoRating;
                if (shouldUpdateName) {
                    masterPlayer.name = fargoName;
                }
            }
            
            // Skip sync for teams/special events
            const isTeamOrSpecialEvent = checkedInPlayer && (checkedInPlayer.isTeam || checkedInPlayer.isSpecialEvent || (checkedInPlayer.playerCount && checkedInPlayer.playerCount > 1));
            
            // Sync to API (only for individual players, not teams)
            if (APPS_SCRIPT_URL && !isTeamOrSpecialEvent) {
                console.log('Syncing Fargo to database:', nameToUse, fargoId, fargoRating, shouldUpdateName ? '(with name update)' : '');
                fetch(APPS_SCRIPT_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'updateFargo',
                        name: localName, // Use original name to find the record
                        newName: shouldUpdateName ? fargoName : null, // New name if updating
                        fargoId: fargoId,
                        skill: fargoRating
                    })
                })
                .then(r => r.json())
                .then(result => {
                    if (result.error) {
                        console.error('API error updating Fargo:', result.error);
                    } else {
                        console.log('Fargo synced to database:', result);
                        if (shouldUpdateName) {
                            showToast(`Name updated to "${fargoName}" and Fargo rating saved`, 'success');
                        } else {
                            showToast('Fargo rating saved to database', 'success');
                        }
                    }
                })
                .catch(err => {
                    console.error('Could not sync Fargo update:', err);
                    showToast('Error saving to database', 'error');
                });
            } else if (isTeamOrSpecialEvent) {
                console.log('Skipping Fargo sync for team/special event:', localName);
            }
            
            pendingFargoSelection = null;
            state.pendingNewPlayer = null;
            closeModal('nameConfirmModal');
            saveToLocalStorage();
            updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
            showToast(`${nameToUse} linked to Fargo ${fargoRating}`, 'success');
        } else {
            // New player
            const player = {
                id: Date.now(),
                name: nameToUse,
                phone: state.pendingNewPlayer.phone,
                fargoId: fargoId,
                fargoName: fargoName,
                skill: fargoRating,
                isNew: true
            };
            
            pendingFargoSelection = null;
            closeModal('nameConfirmModal');
            completeAddPlayer(player);
        }
    }
    
    function reportFargoNameIssue() {
        if (!pendingFargoSelection || !state.pendingNewPlayer) {
            closeModal('nameConfirmModal');
            return;
        }
        
        const { fargoId, fargoName, fargoRating, localName } = pendingFargoSelection;
        
        // Create email content
        const subject = encodeURIComponent('Player profile issue');
        const body = encodeURIComponent(
`Hello FargoRate Support,

I found a spelling issue with a player profile:

FargoRate ID: ${fargoId}
Current name in FargoRate: ${fargoName}
Correct spelling: ${localName}
Current rating: ${fargoRating}

Please update the player's name to the correct spelling.

Thank you!`
        );
        
        // Open email client
        window.open(`mailto:support@fargorate.com?subject=${subject}&body=${body}`, '_blank');
        
        showToast('Email drafted - please send to report the issue', 'info');
        
        // Still link the player with local name (don't update to wrong Fargo name)
        const { fargoId: fId, fargoRating: fRating } = pendingFargoSelection;
        
        if (state.pendingNewPlayer.existingPlayerId) {
            // Update existing player with Fargo info but keep local name
            const playerId = state.pendingNewPlayer.existingPlayerId;
            
            const checkedInPlayer = state.checkedInPlayers.find(p => p.id === playerId);
            if (checkedInPlayer) {
                checkedInPlayer.fargoId = fId;
                checkedInPlayer.fargoName = fargoName; // Store Fargo's version for reference
                checkedInPlayer.skill = fRating;
                // Keep checkedInPlayer.name as-is
            }
            
            const masterPlayer = state.masterPlayers.find(p => p.id === playerId);
            if (masterPlayer) {
                masterPlayer.fargoId = fId;
                masterPlayer.fargoName = fargoName;
                masterPlayer.skill = fRating;
                // Keep masterPlayer.name as-is
            }
            
            // Skip sync for teams/special events
            const isTeamOrSpecialEvent = checkedInPlayer && (checkedInPlayer.isTeam || checkedInPlayer.isSpecialEvent || (checkedInPlayer.playerCount && checkedInPlayer.playerCount > 1));
            
            // Sync Fargo ID and rating to API (but not name change)
            if (APPS_SCRIPT_URL && !isTeamOrSpecialEvent) {
                fetch(APPS_SCRIPT_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'updateFargo',
                        name: localName,
                        fargoId: fId,
                        skill: fRating
                    })
                })
                .then(r => r.json())
                .then(result => console.log('Fargo synced (name kept):', result))
                .catch(err => console.error('Sync error:', err));
            }
            
            pendingFargoSelection = null;
            state.pendingNewPlayer = null;
            closeModal('nameConfirmModal');
            saveToLocalStorage();
            updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
            showToast(`${localName} linked to Fargo ${fRating} (name issue reported)`, 'success');
        } else {
            // New player - use local name
            const player = {
                id: Date.now(),
                name: localName,
                phone: state.pendingNewPlayer.phone,
                fargoId: fId,
                fargoName: fargoName,
                skill: fRating,
                isNew: true
            };
            
            pendingFargoSelection = null;
            closeModal('nameConfirmModal');
            completeAddPlayer(player);
        }
    }
    
    function skipFargoSelection() {
        if (!state.pendingNewPlayer) {
            closeModal('fargoModal');
            return;
        }
        
        // Check if this was linking an existing player
        if (state.pendingNewPlayer.existingPlayerId) {
            state.pendingNewPlayer = null;
            closeModal('fargoModal');
            showToast('FargoRate lookup skipped', 'info');
            return;
        }
        
        // Get pending info
        const hasPaid = state.pendingNewPlayer.hasPaid ?? false;
        const inSidePot = state.pendingNewPlayer.inSidePot ?? false;
        const isLate = state.pendingNewPlayer.isLate ?? false;
        const carrier = state.pendingNewPlayer.carrier || '';
        
        const player = {
            id: Date.now(),
            name: state.pendingNewPlayer.name,
            phone: state.pendingNewPlayer.phone || '',
            fargoId: null,
            skill: null,
            carrier: carrier,
            isNew: true
        };
        
        // Add to master players
        state.masterPlayers.push(player);
        
        // Add to checked-in players
        state.checkedInPlayers.push({
            ...player,
            checkedInAt: new Date().toISOString(),
            hasPaid: hasPaid,
            inSidePot: inSidePot,
            isLate: isLate,
            calcuttaBuyer: '',
            calcuttaBid: 0,
            calcuttaPaid: false
        });
        
        state.pendingNewPlayer = null;
        closeModal('fargoModal');
        saveToLocalStorage();
        updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
        
        // Focus back on input
        setTimeout(() => {
            const input = document.getElementById('newPlayerInput');
            if (input) {
                input.value = '';
                input.focus();
            }
        }, 50);
        
        showToast(`${player.name} added (no Fargo rating)`, 'success');
    }
    
    // Update player phone from spreadsheet
    async function updatePlayerPhone(playerId, phone) {
        const player = state.checkedInPlayers.find(p => p.id === playerId);
        if (player) {
            player.phone = phone;
            
            // Also update in master list if exists
            const masterPlayer = state.masterPlayers.find(p => 
                p.name.toLowerCase() === player.name.toLowerCase() || p.id === player.originalId
            );
            if (masterPlayer) {
                masterPlayer.phone = phone;
            }
            
            saveToLocalStorage();
            
            // Skip sync for teams/special events
            const isTeamOrSpecialEvent = player.isTeam || player.isSpecialEvent || (player.playerCount && player.playerCount > 1);
            
            // Sync to API in background (only for individual players, not teams)
            if (APPS_SCRIPT_URL && !isTeamOrSpecialEvent) {
                try {
                    console.log('Syncing phone to database:', player.name, phone);
                    const response = await fetch(APPS_SCRIPT_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'text/plain' },
                        body: JSON.stringify({
                            action: 'updatePhone',
                            name: player.name,
                            phone: phone
                        })
                    });
                    const result = await response.json();
                    if (result.error) {
                        console.error('API error updating phone:', result.error);
                        showToast('Error saving phone: ' + result.error, 'error');
                    } else {
                        console.log('Phone synced to database:', result);
                        showToast('Phone saved to database', 'success');
                    }
                } catch (error) {
                    console.error('Could not sync phone to database:', error);
                    showToast('Error saving to database', 'error');
                }
            } else if (isTeamOrSpecialEvent) {
                console.log('Skipping phone sync for team/special event:', player.name);
            }
        }
    }
    
    async function completeAddPlayer(player) {
        // Include carrier from pending player if available
        const carrier = state.pendingNewPlayer?.carrier || '';
        player.carrier = carrier;
        
        // Try to add to master database via API
        // Skip for special events/teams - they shouldn't be added to the master player database
        const isTeamOrSpecialEvent = player.isTeam || player.isSpecialEvent || (player.playerCount && player.playerCount > 1);
        
        if (APPS_SCRIPT_URL && !isTeamOrSpecialEvent) {
            try {
                const response = await fetch(APPS_SCRIPT_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'addPlayer',
                        name: player.name,
                        phone: player.phone,
                        skill: player.skill,
                        fargoId: player.fargoId,
                        carrier: carrier
                    })
                });
                
                const result = await response.json();
                if (result.error) {
                    console.warn('API add player warning:', result.error);
                }
            } catch (error) {
                console.warn('Could not sync to database:', error);
            }
        } else if (isTeamOrSpecialEvent) {
            console.log('Skipping database sync for team/special event:', player.name);
        }
        
        state.masterPlayers.push(player);
        
        // Check if we have pending payment/sidepot/late info from quick add
        const hasPaid = state.pendingNewPlayer?.hasPaid ?? false;
        const inSidePot = state.pendingNewPlayer?.inSidePot ?? false;
        const isLate = state.pendingNewPlayer?.isLate ?? false;
        
        // Add to checked-in players
        state.checkedInPlayers.push({
            ...player,
            checkedInAt: new Date().toISOString(),
            hasPaid: hasPaid,
            inSidePot: inSidePot,
            isLate: isLate,
            carrier: carrier,
            calcuttaBuyer: '',
            calcuttaBid: 0,
            calcuttaPaid: false
        });
        
        // Clear pending
        state.pendingNewPlayer = null;
        
        closeModal('fargoModal');
        saveToLocalStorage();
        updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
        
        // Focus back on new player input
        setTimeout(() => {
            const input = document.getElementById('newPlayerInput');
            if (input) {
                input.value = '';
                input.focus();
            }
        }, 50);
        
        const ratingMsg = player.skill ? ` (Fargo ${player.skill})` : '';
        showToast(`${player.name} added and checked in${ratingMsg}`, 'success');
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Escape text for use inside JavaScript string literals (handles quotes)
    function escapeForJs(text) {
        if (!text) return '';
        return text.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"');
    }
    
    // Global test function - call from console: testAPI()
    window.testAPI = async function() {
        console.log('Testing API connection...');
        console.log('URL:', APPS_SCRIPT_URL);
        try {
            const response = await fetch(APPS_SCRIPT_URL + '?action=getMasterPlayers');
            const data = await response.json();
            console.log('API Response:', data);
            console.log('Players returned:', data.players?.length || 0);
            if (data.players && data.players.length > 0) {
                console.log('First player:', data.players[0]);
            }
            return data;
        } catch (e) {
            console.error('API Error:', e);
            return null;
        }
    };
    
    // Test UPDATE to API - call from console: testUpdate('Aaron Muncy')
    window.testUpdate = async function(playerName) {
        if (!playerName) {
            console.log('Usage: testUpdate("Aaron Muncy")');
            return;
        }
        console.log('Testing API UPDATE for:', playerName);
        console.log('URL:', APPS_SCRIPT_URL);
        
        const testPhone = '(555) 999-' + Math.floor(1000 + Math.random() * 9000);
        console.log('Setting test phone to:', testPhone);
        
        try {
            const response = await fetch(APPS_SCRIPT_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify({
                    action: 'updatePhone',
                    name: playerName,
                    phone: testPhone
                })
            });
            
            console.log('Response status:', response.status);
            const text = await response.text();
            console.log('Raw response:', text);
            
            try {
                const data = JSON.parse(text);
                console.log('Parsed response:', data);
                if (data.error) {
                    console.error('‚ùå API returned error:', data.error);
                } else {
                    console.log('‚úÖ SUCCESS! Check your Google Sheet for', playerName);
                    console.log('Phone should now be:', testPhone);
                }
                return data;
            } catch (e) {
                console.error('Could not parse response as JSON');
                return text;
            }
        } catch (e) {
            console.error('‚ùå Fetch error:', e);
            return null;
        }
    };
    
    // Global function to check state - call from console: checkState()
    window.checkState = function() {
        console.log('=== Current State ===');
        console.log('Master Players:', state.masterPlayers.length);
        console.log('Checked In:', state.checkedInPlayers.length);
        console.log('Event Type:', state.eventType);
        if (state.masterPlayers.length > 0) {
            console.log('First 3 master players:');
            state.masterPlayers.slice(0, 3).forEach(p => console.log('  -', p.name, '| phone:', p.phone));
        }
        return state;
    };
    
    // Global function to manually search - call from console: testSearch('jason')
    window.testSearch = function(query) {
        console.log(`Searching for "${query}" in ${state.masterPlayers.length} players...`);
        const matches = state.masterPlayers.filter(p => 
            p.name.toLowerCase().includes(query.toLowerCase())
        );
        console.log(`Found ${matches.length} matches:`);
        matches.forEach(p => console.log('  -', p.name, '| phone:', p.phone, '| id:', p.id));
        return matches;
    };
    
    // Test API POST request - call from console: testUpdate('Aaron Muncy')
    window.testUpdate = async function(playerName) {
        console.log('Testing API POST to update phone for:', playerName);
        console.log('URL:', APPS_SCRIPT_URL);
        try {
            const response = await fetch(APPS_SCRIPT_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify({
                    action: 'updatePhone',
                    name: playerName,
                    phone: '(555) 123-4567'
                })
            });
            console.log('Response status:', response.status);
            const text = await response.text();
            console.log('Raw response:', text);
            try {
                const data = JSON.parse(text);
                console.log('Parsed response:', data);
                if (data.error) {
                    console.error('API returned error:', data.error);
                } else {
                    console.log('SUCCESS! Check your Google Sheet for', playerName);
                }
                return data;
            } catch (e) {
                console.log('Response was not JSON');
                return text;
            }
        } catch (e) {
            console.error('API Error:', e);
            return null;
        }
    };
    
    // Refresh Fargo rating for a player
    async function refreshFargoRating(playerId) {
        const player = state.checkedInPlayers.find(p => p.id === playerId);
        if (!player || !player.fargoId) {
            showToast('No FargoRate ID for this player', 'error');
            return;
        }
        
        try {
            // Search by fargoId prefix to find current rating
            const response = await fetch(FARGO_API_URL + '?q=' + encodeURIComponent(player.fargoId));
            const data = await response.json();
            
            if (data.value && data.value.length > 0) {
                // Find matching player by ID prefix
                const match = data.value.find(p => p.id && p.id.startsWith(player.fargoId));
                if (match && (match.effectiveRating || match.rating)) {
                    const newRating = parseInt(match.effectiveRating || match.rating);
                    player.skill = newRating;
                    
                    // Update in master list too
                    const masterPlayer = state.masterPlayers.find(p => p.id === playerId);
                    if (masterPlayer) {
                        masterPlayer.skill = newRating;
                    }
                    
                    saveToLocalStorage();
                    updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
                    showToast(`${player.name} updated to Fargo ${match.rating}`, 'success');
                    return;
                }
            }
            
            showToast('Could not find updated rating', 'error');
        } catch (error) {
            showToast('Error refreshing rating: ' + error.message, 'error');
        }
    }
    
    function showEditPhoneModal(playerId) {
        const player = state.checkedInPlayers.find(p => p.id === playerId);
        if (!player) return;
        
        state.editingPlayerId = playerId;
        document.getElementById('editPhonePlayerName').value = player.name;
        document.getElementById('editPhoneNumber').value = player.phone || '';
        document.getElementById('editPhoneModal').classList.add('show');
    }
    
    async function savePhoneUpdate() {
        const phone = document.getElementById('editPhoneNumber').value.trim();
        
        // Get player name for API call
        const checkedInPlayer = state.checkedInPlayers.find(p => p.id === state.editingPlayerId);
        const playerName = checkedInPlayer ? checkedInPlayer.name : null;
        
        // Update in checked in list
        if (checkedInPlayer) {
            checkedInPlayer.phone = phone;
        }
        
        // Update in master list
        const masterPlayer = state.masterPlayers.find(p => p.id === state.editingPlayerId);
        if (masterPlayer) {
            masterPlayer.phone = phone;
        }
        
        // Skip sync for teams/special events
        const isTeamOrSpecialEvent = checkedInPlayer && (checkedInPlayer.isTeam || checkedInPlayer.isSpecialEvent || (checkedInPlayer.playerCount && checkedInPlayer.playerCount > 1));
        
        // Try to update in database via API (only for individual players, not teams)
        if (APPS_SCRIPT_URL && playerName && !isTeamOrSpecialEvent) {
            try {
                console.log('Saving phone to database:', playerName, phone);
                showToast('Saving to database...', 'info');
                
                const response = await fetch(APPS_SCRIPT_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'updatePhone',
                        name: playerName,
                        phone: phone
                    })
                });
                
                const result = await response.json();
                console.log('API response:', result);
                
                if (result.error) {
                    console.error('API error:', result.error);
                    showToast('Database error: ' + result.error, 'error');
                } else {
                    showToast('Phone saved to database ‚úì', 'success');
                }
            } catch (error) {
                console.error('Could not sync phone update to database:', error);
                showToast('Could not save to database', 'error');
            }
        } else if (isTeamOrSpecialEvent) {
            console.log('Skipping phone sync for team/special event:', playerName);
            showToast('Phone updated locally', 'success');
        } else {
            showToast('Phone updated locally', 'success');
        }
        
        closeModal('editPhoneModal');
        saveToLocalStorage();
        updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
    }
    
    // ============================================================================
    // EDIT PLAYER
    // ============================================================================
    
    function showEditPlayerModal(playerId) {
        const player = state.checkedInPlayers.find(p => p.id === playerId);
        if (!player) {
            showToast('Player not found', 'error');
            return;
        }
        
        // Populate modal fields
        document.getElementById('editPlayerOriginalName').value = player.name;
        document.getElementById('editPlayerId').value = playerId;
        document.getElementById('editPlayerName').value = player.name;
        document.getElementById('editPlayerPhone').value = player.phone || '';
        document.getElementById('editPlayerCarrier').value = player.carrier || '';
        document.getElementById('editPlayerSkill').value = player.skill || '';
        
        document.getElementById('editPlayerModal').classList.add('show');
    }
    
    function lookupFargoForEdit() {
        const name = document.getElementById('editPlayerName').value.trim();
        if (!name) {
            showToast('Enter a name first', 'error');
            return;
        }
        
        // Store context for Fargo lookup
        state.pendingNewPlayer = {
            existingPlayerId: document.getElementById('editPlayerId').value,
            name: name,
            isEdit: true
        };
        
        closeModal('editPlayerModal');
        
        // Open Fargo modal with name pre-filled
        document.getElementById('fargoSearchInput').value = name;
        document.getElementById('fargoResultsList').innerHTML = '';
        document.getElementById('fargoModal').classList.add('show');
        
        searchFargo();
    }
    
    async function savePlayerEdit() {
        const playerId = parseInt(document.getElementById('editPlayerId').value);
        const originalName = document.getElementById('editPlayerOriginalName').value;
        const newName = document.getElementById('editPlayerName').value.trim();
        const phone = document.getElementById('editPlayerPhone').value.trim();
        const carrier = document.getElementById('editPlayerCarrier').value;
        const skill = document.getElementById('editPlayerSkill').value;
        
        if (!newName) {
            showToast('Name is required', 'error');
            return;
        }
        
        // Update checked-in player
        const checkedInPlayer = state.checkedInPlayers.find(p => p.id === playerId);
        if (checkedInPlayer) {
            checkedInPlayer.name = newName;
            checkedInPlayer.phone = phone;
            checkedInPlayer.carrier = carrier;
            checkedInPlayer.skill = skill ? parseInt(skill) : null;
        }
        
        // Update master player
        const masterPlayer = state.masterPlayers.find(p => 
            p.name.toLowerCase() === originalName.toLowerCase()
        );
        if (masterPlayer) {
            masterPlayer.name = newName;
            masterPlayer.phone = phone;
            masterPlayer.carrier = carrier;
            masterPlayer.skill = skill ? parseInt(skill) : null;
        }
        
        // Skip sync for teams/special events
        const isTeamOrSpecialEvent = checkedInPlayer && (checkedInPlayer.isTeam || checkedInPlayer.isSpecialEvent || (checkedInPlayer.playerCount && checkedInPlayer.playerCount > 1));
        
        // Sync to API (only for individual players, not teams)
        if (APPS_SCRIPT_URL && !isTeamOrSpecialEvent) {
            try {
                showToast('Saving to database...', 'info');
                const response = await fetch(APPS_SCRIPT_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'updatePlayer',
                        originalName: originalName,
                        newName: newName,
                        phone: phone,
                        carrier: carrier,
                        skill: skill ? parseInt(skill) : null
                    })
                });
                
                const result = await response.json();
                if (result.error) {
                    console.warn('API update warning:', result.error);
                    showToast('Local save only: ' + result.error, 'warning');
                } else {
                    showToast('Player updated in database', 'success');
                }
            } catch (error) {
                console.warn('Could not sync to database:', error);
                showToast('Saved locally (database sync failed)', 'warning');
            }
        } else if (isTeamOrSpecialEvent) {
            console.log('Skipping database sync for team/special event:', originalName);
            showToast('Player updated locally', 'success');
        } else {
            showToast('Player updated', 'success');
        }
        
        closeModal('editPlayerModal');
        saveToLocalStorage();
        updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
    }
    
    // ============================================================================
    // SIDE POT
    // ============================================================================
    
    function toggleSidePot(playerId) {
        const player = state.checkedInPlayers.find(p => p.id === playerId);
        if (player) {
            player.inSidePot = !player.inSidePot;
            saveToLocalStorage();
            updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
        }
    }
    
    // ============================================================================
    // CALCUTTA
    // ============================================================================
    
    function updateCalcuttaBuyer(playerId, buyer) {
        const player = state.checkedInPlayers.find(p => p.id === playerId);
        if (player) {
            const wasPool = isPoolBuyer(player.calcuttaBuyer);
            const isNowPool = isPoolBuyer(buyer);
            
            player.calcuttaBuyer = buyer;
            
            // If buyer is "pool", set bid to 0 and paid to false
            if (isNowPool) {
                player.calcuttaBid = 0;
                player.calcuttaPaid = false;
            }
            
            saveToLocalStorage();
            
            // Only re-render if pool status changed (player needs to move)
            if (wasPool !== isNowPool) {
                renderCalcuttaTable();
            }
            
            updateCalcuttaSummary();
            updateBuyersSummary();
        }
    }
    
    function updateCalcuttaBid(playerId, bid) {
        const player = state.checkedInPlayers.find(p => p.id === playerId);
        if (player) {
            player.calcuttaBid = parseFloat(bid) || 0;
            saveToLocalStorage();
            updateCalcuttaSummary();
            updateBuyersSummary();
        }
    }
    
    function toggleCalcuttaPaid(playerId) {
        const player = state.checkedInPlayers.find(p => p.id === playerId);
        if (player) {
            player.calcuttaPaid = !player.calcuttaPaid;
            saveToLocalStorage();
            updateCalcuttaSummary();
            updateBuyersSummary();
        }
    }
    
    function toggleSelfBuyer(playerId, playerName) {
        const player = state.checkedInPlayers.find(p => p.id === playerId);
        if (player) {
            // If currently self, clear it. If not self, set to self.
            if (player.calcuttaBuyer === playerName) {
                player.calcuttaBuyer = '';
            } else {
                player.calcuttaBuyer = playerName;
            }
            saveToLocalStorage();
            renderCalcuttaTable();
            updateCalcuttaSummary();
            updateBuyersSummary();
        }
    }
    
    function sortCalcutta(sortBy) {
        state.calcuttaSort = sortBy;
        
        // Update button states
        document.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById('sort' + sortBy.charAt(0).toUpperCase() + sortBy.slice(1)).classList.add('active');
        
        renderCalcuttaTable();
    }
    
    function getSortedCalcuttaPlayers() {
        // Only show players who are paid or running late in the Calcutta
        const players = state.checkedInPlayers.filter(p => p.hasPaid || p.isLate);
        
        switch (state.calcuttaSort) {
            case 'name':
                return players.sort((a, b) => a.name.localeCompare(b.name));
            case 'skill':
                return players.sort((a, b) => (b.skill || 0) - (a.skill || 0));
            case 'bid':
                return players.sort((a, b) => (b.calcuttaBid || 0) - (a.calcuttaBid || 0));
            case 'order':
            default:
                return players; // Already in check-in order
        }
    }
    
    // ============================================================================
    // BUYERS SUMMARY
    // ============================================================================
    
    function getBuyersSummary() {
        const buyers = {};
        
        // Only include paid or late players
        const eligiblePlayers = state.checkedInPlayers.filter(p => p.hasPaid || p.isLate);
        
        // Get pool players (from eligible players)
        const poolPlayers = eligiblePlayers.filter(p => isPoolBuyer(p.calcuttaBuyer));
        
        // Add regular players (not pool)
        eligiblePlayers.forEach(player => {
            if (player.calcuttaBuyer && player.calcuttaBid > 0 && !isPoolBuyer(player.calcuttaBuyer)) {
                const buyerName = player.calcuttaBuyer.trim();
                if (!buyers[buyerName]) {
                    buyers[buyerName] = {
                        name: buyerName,
                        totalOwed: 0,
                        players: [],
                        paid: true
                    };
                }
                buyers[buyerName].totalOwed += player.calcuttaBid;
                buyers[buyerName].players.push(player.name);
                if (!player.calcuttaPaid) {
                    buyers[buyerName].paid = false;
                }
            }
        });
        
        // Add pool to buyer if there's a pool auction
        if (poolPlayers.length > 0 && state.poolAuction.buyer) {
            const poolBuyerName = state.poolAuction.buyer.trim();
            if (poolBuyerName) {
                if (!buyers[poolBuyerName]) {
                    buyers[poolBuyerName] = {
                        name: poolBuyerName,
                        totalOwed: 0,
                        players: [],
                        paid: true
                    };
                }
                buyers[poolBuyerName].totalOwed += state.poolAuction.bid || 0;
                buyers[poolBuyerName].players.push(`Pool (${poolPlayers.length})`);
                if (!state.poolAuction.paid && state.poolAuction.bid > 0) {
                    buyers[poolBuyerName].paid = false;
                }
            }
        }
        
        return Object.values(buyers).sort((a, b) => b.totalOwed - a.totalOwed);
    }
    
    function toggleBuyerPaid(buyerName) {
        // Check if this buyer has any pool auctions
        const isPoolBuyerForThisBuyer = state.poolAuction.buyer === buyerName;
        
        // Get current paid status for regular players
        const regularPlayers = state.checkedInPlayers.filter(p => p.calcuttaBuyer === buyerName);
        const regularAllPaid = regularPlayers.length === 0 || regularPlayers.every(p => p.calcuttaPaid);
        
        // Check pool paid status
        const poolPaid = isPoolBuyerForThisBuyer ? state.poolAuction.paid : true;
        
        // Overall paid status
        const isPaid = regularAllPaid && poolPaid;
        
        // Toggle regular players
        state.checkedInPlayers.forEach(player => {
            if (player.calcuttaBuyer === buyerName) {
                player.calcuttaPaid = !isPaid;
            }
        });
        
        // Toggle pool if this buyer owns the pool
        if (isPoolBuyerForThisBuyer) {
            state.poolAuction.paid = !isPaid;
        }
        
        saveToLocalStorage();
        updateCalcuttaSummary();
        updateBuyersSummary();
        renderCalcuttaTable();
    }
    
    function markAllPaid() {
        if (confirm('Mark all buyers as paid?')) {
            state.checkedInPlayers.forEach(player => {
                if (player.calcuttaBid > 0) {
                    player.calcuttaPaid = true;
                }
            });
            // Also mark pool as paid
            if (state.poolAuction.bid > 0) {
                state.poolAuction.paid = true;
            }
            saveToLocalStorage();
            updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
            showToast('All buyers marked as paid', 'success');
        }
    }
    
    // ============================================================================
    // DISPLAY UPDATES
    // ============================================================================
    
    function updateAllDisplays() {
        renderPlayerSpreadsheet();
        renderSidepotList();
        renderCalcuttaTable();
        updateBuyersSummary();
        updateSummaryCards();
        updateBadges();
        updatePayoutsDisplay();
        
        // Update DB player count indicator
        const dbCount = document.getElementById('dbPlayerCount');
        if (dbCount) {
            dbCount.textContent = `DB: ${state.masterPlayers.length}`;
            dbCount.style.color = state.masterPlayers.length > 0 ? '#16a34a' : '#dc2626';
        }
    }
    
    // ============================================================================
    // SPREADSHEET-STYLE PLAYER ENTRY
    // ============================================================================
    
    function renderPlayerSpreadsheet() {
        const tbody = document.getElementById('playerTableBody');
        if (!tbody) return;
        
        const isSpecialEvent = state.eventType === 'special';
        const hideSidePot = isSpecialEvent && !state.tournamentSettings.sidepot;
        const hideCarrier = isSpecialEvent; // Always hide carrier for special events
        
        // Update header visibility
        const thCarrier = document.getElementById('thCarrier');
        const thSidePot = document.getElementById('thSidePot');
        if (thCarrier) thCarrier.style.display = hideCarrier ? 'none' : '';
        if (thSidePot) thSidePot.style.display = hideSidePot ? 'none' : '';
        
        const carrierOptions = `
            <option value="">--</option>
            <option value="verizon">Verizon</option>
            <option value="att">AT&T</option>
            <option value="tmobile">T-Mobile</option>
            <option value="sprint">Sprint</option>
            <option value="uscellular">US Cellular</option>
            <option value="cricket">Cricket</option>
            <option value="metropcs">Metro PCS</option>
            <option value="boost">Boost</option>
            <option value="virgin">Virgin</option>
            <option value="googlefi">Google Fi</option>
            <option value="xfinity">Xfinity</option>
            <option value="spectrum">Spectrum</option>
            <option value="consumer_cellular">Consumer Cellular</option>
            <option value="mint">Mint</option>
            <option value="visible">Visible</option>
            <option value="straight_talk">Straight Talk</option>
            <option value="other">Other</option>
        `;
        
        let html = '';
        
        // Render existing players
        state.checkedInPlayers.forEach((player, index) => {
            const rowClass = player.hasPaid ? 'paid-row' : 'unpaid-row';
            const carrierValue = player.carrier || '';
            
            // Build carrier select with current value selected
            let carrierSelect = carrierOptions.replace(
                `value="${carrierValue}"`, 
                `value="${carrierValue}" selected`
            );
            
            // Show Fargo lookup only for non-special events and players without fargoId
            const showFargoLookup = !isSpecialEvent && !player.fargoId;
            
            html += `
                <tr class="${rowClass}" data-player-id="${player.id}">
                    <td class="row-number">${index + 1}</td>
                    <td>
                        <input type="text" value="${escapeHtml(player.name)}" 
                               readonly 
                               style="font-weight:500;">
                    </td>
                    <td>
                        <input type="tel" value="${player.phone || ''}" 
                               onchange="updatePlayerPhone(${player.id}, this.value)"
                               placeholder="Phone">
                    </td>
                    ${hideCarrier ? '' : `
                    <td>
                        <select class="carrier-select" onchange="updatePlayerCarrier(${player.id}, this.value)">
                            ${carrierSelect}
                        </select>
                    </td>
                    `}
                    <td>
                        <div style="display:flex; align-items:center; gap:4px;">
                            <input type="number" 
                                   class="skill-edit-input"
                                   value="${player.skill || ''}" 
                                   placeholder="-"
                                   min="0" max="900"
                                   onchange="updatePlayerSkill(${player.id}, this.value)"
                                   style="width:55px; text-align:center; padding:4px; border:1px solid ${player.skill ? 'transparent' : '#f59e0b'}; border-radius:4px; background:${player.skill ? 'transparent' : '#fffbeb'};">
                            ${showFargoLookup ? `<button class="btn btn-small" onclick="linkToFargo(${player.id})" title="Search FargoRate to find this player's rating" style="font-size:0.7rem;padding:2px 4px;">üîç</button>` : ''}
                        </div>
                    </td>
                    ${hideSidePot ? '' : `
                    <td style="text-align:center;">
                        <input type="checkbox" ${player.inSidePot ? 'checked' : ''} 
                               onchange="toggleSidePot(${player.id})">
                    </td>
                    `}
                    <td style="text-align:center;">
                        <input type="checkbox" ${player.hasPaid ? 'checked' : ''} 
                               onchange="togglePaid(${player.id})">
                    </td>
                    <td style="text-align:center;">
                        <input type="checkbox" ${player.isLate ? 'checked' : ''} 
                               onchange="toggleLate(${player.id})"
                               title="Running Late">
                    </td>
                    <td>
                        <button class="edit-btn" onclick="showEditPlayerModal(${player.id})" title="Edit player details">‚úé</button>
                        <button class="delete-btn" onclick="removePlayer(${player.id})" title="Remove player from check-in list">‚úï</button>
                    </td>
                </tr>
            `;
        });
        
        // Add empty row for new entry - ONLY for recurring tournaments, not special events
        if (!isSpecialEvent) {
            const newRowNum = state.checkedInPlayers.length + 1;
            html += `
                <tr class="empty-row" data-row="new">
                    <td class="row-number">${newRowNum}</td>
                    <td>
                        <div class="inline-autocomplete">
                            <input type="text" id="newPlayerInput" 
                                   placeholder="Type player name..."
                                   oninput="handleInlinePlayerSearch(this.value)"
                                   onkeydown="handleInlineAutocompleteKeydown(event)"
                                   onfocus="this.select()">
                            <div class="inline-autocomplete-list" id="inlineAutocompleteList"></div>
                        </div>
                    </td>
                    <td>
                        <input type="tel" id="newPlayerPhone" placeholder="Phone" readonly>
                    </td>
                    ${hideCarrier ? '' : `
                    <td>
                        <select class="carrier-select" id="newPlayerCarrier" disabled>
                            ${carrierOptions}
                        </select>
                    </td>
                    `}
                    <td class="fargo-display" id="newPlayerFargo">-</td>
                    ${hideSidePot ? '' : `
                    <td style="text-align:center;">
                        <input type="checkbox" id="newPlayerSidepot">
                    </td>
                    `}
                    <td style="text-align:center;">
                        <input type="checkbox" id="newPlayerPaid">
                    </td>
                    <td style="text-align:center;">
                        <input type="checkbox" id="newPlayerLate" title="Running Late">
                    </td>
                    <td></td>
                </tr>
            `;
        }
        
        tbody.innerHTML = html;
        
        // Update count display
        const countDisplay = document.getElementById('playerCountDisplay');
        if (countDisplay) {
            countDisplay.textContent = `${state.checkedInPlayers.length} player${state.checkedInPlayers.length !== 1 ? 's' : ''}`;
        }
    }
    
    // Update player carrier
    async function updatePlayerCarrier(playerId, carrier) {
        const player = state.checkedInPlayers.find(p => p.id === playerId);
        if (player) {
            player.carrier = carrier;
            
            // Also update in master list if exists
            const masterPlayer = state.masterPlayers.find(p => 
                p.name.toLowerCase() === player.name.toLowerCase() || p.id === player.originalId
            );
            if (masterPlayer) {
                masterPlayer.carrier = carrier;
            }
            
            saveToLocalStorage();
            
            // Skip sync for teams/special events
            const isTeamOrSpecialEvent = player.isTeam || player.isSpecialEvent || (player.playerCount && player.playerCount > 1);
            
            // Sync to API in background (only for individual players, not teams)
            if (APPS_SCRIPT_URL && !isTeamOrSpecialEvent) {
                try {
                    console.log('Syncing carrier to database:', player.name, carrier);
                    const response = await fetch(APPS_SCRIPT_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'text/plain' },
                        body: JSON.stringify({
                            action: 'updateCarrier',
                            name: player.name,
                            carrier: carrier,
                            phone: player.phone
                        })
                    });
                    const result = await response.json();
                    if (result.error) {
                        console.error('API error updating carrier:', result.error);
                        showToast('Error saving carrier: ' + result.error, 'error');
                    } else {
                        console.log('Carrier synced to database:', result);
                        showToast('Carrier saved to database', 'success');
                    }
                } catch (error) {
                    console.error('Could not sync carrier to database:', error);
                    showToast('Error saving to database', 'error');
                }
            } else if (isTeamOrSpecialEvent) {
                console.log('Skipping carrier sync for team/special event:', player.name);
            }
        }
    }
    
    function handleInlinePlayerSearch(query) {
        const input = document.getElementById('newPlayerInput');
        const list = document.getElementById('inlineAutocompleteList');
        
        // DEBUG - show what's happening
        console.log('=== SEARCH TRIGGERED ===');
        console.log('Query:', query);
        console.log('Master players loaded:', state.masterPlayers.length);
        
        if (query.length < 2) {
            list.classList.remove('show');
            return;
        }
        
        // Debug: Check if we have players loaded
        if (state.masterPlayers.length === 0) {
            console.error('NO MASTER PLAYERS LOADED!');
            alert('No players loaded! Click the üîÑ Refresh button first.');
            return;
        }
        
        // Position the dropdown below the input using fixed positioning
        const rect = input.getBoundingClientRect();
        list.style.position = 'fixed';
        list.style.top = (rect.bottom + 2) + 'px';
        list.style.left = rect.left + 'px';
        list.style.width = Math.max(rect.width, 350) + 'px';
        list.style.zIndex = '99999';
        list.style.background = 'white';
        list.style.border = '2px solid #16a34a';
        list.style.boxShadow = '0 8px 24px rgba(0,0,0,0.4)';
        
        // Search master players - don't filter by checked in for now
        const matches = state.masterPlayers.filter(p => 
            p.name.toLowerCase().includes(query.toLowerCase())
        ).slice(0, 10);
        
        // Debug log
        console.log(`Found ${matches.length} matches for "${query}"`);
        if (matches.length > 0) {
            console.log('First match:', matches[0].name, '- phone:', matches[0].phone);
        }
        
        if (matches.length === 0) {
            // Show option to add as new player
            list.innerHTML = `
                <div class="inline-autocomplete-item" onclick="addNewPlayerQuick('${escapeForJs(query)}')">
                    <div>
                        <div class="player-name">‚ûï Add "${escapeHtml(query)}" as new player</div>
                        <div class="player-details">Not found in ${state.masterPlayers.length} players</div>
                    </div>
                </div>
            `;
            list.classList.add('show');
            list.style.display = 'block';
            return;
        }
        
        // Check if already checked in
        const alreadyCheckedIn = state.checkedInPlayers.map(p => p.originalId || p.id);
        
        list.innerHTML = matches.map((p, i) => {
            const isCheckedIn = alreadyCheckedIn.includes(p.id);
            return `
            <div class="inline-autocomplete-item" onclick="selectInlinePlayer(${p.id})" style="${isCheckedIn ? 'opacity:0.5;' : ''}">
                <div>
                    <div class="player-name">${highlightMatch(p.name, query)} ${isCheckedIn ? '<span style="color:#f59e0b;">(checked in)</span>' : ''}</div>
                    <div class="player-details">${p.phone || '<span style="color:#f59e0b;">No phone</span>'} ${p.skill ? '‚Ä¢ Fargo ' + p.skill : ''}</div>
                </div>
                ${p.skill ? `<span class="fargo-badge">${p.skill}</span>` : '<span class="fargo-badge" style="background:#9ca3af;">?</span>'}
            </div>
        `}).join('') + `
            <div class="inline-autocomplete-item" onclick="addNewPlayerQuick('${escapeForJs(query)}')" style="border-top:2px solid var(--border); background:#f8fafc;">
                <div>
                    <div class="player-name" style="color:var(--text-light);">‚ûï Add "${escapeHtml(query)}" as new player</div>
                </div>
            </div>
        `;
        
        list.classList.add('show');
        list.style.display = 'block';
        console.log('Dropdown should now be visible');
    }
    
    function handleInlineAutocompleteKeydown(event) {
        const list = document.getElementById('inlineAutocompleteList');
        const items = list.querySelectorAll('.inline-autocomplete-item');
        
        if (event.key === 'Escape') {
            list.classList.remove('show');
        } else if (event.key === 'Enter') {
            event.preventDefault();
            if (items.length > 0) {
                items[0].click();
            }
        }
    }
    
    async function selectInlinePlayer(playerId) {
        const player = state.masterPlayers.find(p => p.id === playerId);
        if (!player) return;
        
        const hasPaid = document.getElementById('newPlayerPaid')?.checked ?? false;
        const inSidePot = document.getElementById('newPlayerSidepot')?.checked ?? false;
        const isLate = document.getElementById('newPlayerLate')?.checked ?? false;
        
        // Create the checked-in player entry
        const checkedInPlayer = {
            ...player,
            id: Date.now(), // New unique ID for this check-in
            originalId: player.id,
            checkedInAt: new Date().toISOString(),
            hasPaid: hasPaid,
            inSidePot: inSidePot,
            isLate: isLate,
            carrier: player.carrier || '', // Copy carrier from master
            calcuttaBuyer: '',
            calcuttaBid: 0,
            calcuttaPaid: false,
            isSpecialEvent: player.isSpecialEvent || false // Preserve special event flag
        };
        
        // Add to checked-in players
        state.checkedInPlayers.push(checkedInPlayer);
        
        // Hide autocomplete
        document.getElementById('inlineAutocompleteList').classList.remove('show');
        
        saveToLocalStorage();
        updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
        
        // Focus back on input for next entry
        setTimeout(() => {
            const input = document.getElementById('newPlayerInput');
            if (input) {
                input.value = '';
                input.focus();
            }
        }, 50);
        
        // If player has fargoId and is NOT a special event, auto-refresh their rating in background
        // Special events use the rating at time of registration, not current rating
        if (player.fargoId && !player.isSpecialEvent) {
            autoRefreshFargoRating(checkedInPlayer.id, player.fargoId, player.name);
        }
        
        showToast(`${player.name} checked in${player.skill ? ` (Fargo ${player.skill})` : ''}`, 'success');
    }
    
    // Auto-refresh Fargo rating when checking in a known player
    async function autoRefreshFargoRating(checkedInPlayerId, fargoId, playerName) {
        try {
            const response = await fetch(FARGO_API_URL + '?q=' + encodeURIComponent(fargoId));
            const data = await response.json();
            
            if (data.value && data.value.length > 0) {
                // Find matching player by ID prefix
                const match = data.value.find(p => p.id && p.id.toUpperCase().startsWith(fargoId.toUpperCase()));
                if (match && (match.effectiveRating || match.rating)) {
                    const newRating = parseInt(match.effectiveRating || match.rating);
                    
                    // Update checked-in player
                    const checkedInPlayer = state.checkedInPlayers.find(p => p.id === checkedInPlayerId);
                    if (checkedInPlayer && checkedInPlayer.skill !== newRating) {
                        const oldRating = checkedInPlayer.skill;
                        checkedInPlayer.skill = newRating;
                        
                        // Update master player too
                        const masterPlayer = state.masterPlayers.find(p => p.fargoId === fargoId);
                        if (masterPlayer) {
                            masterPlayer.skill = newRating;
                        }
                        
                        saveToLocalStorage();
                        updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
                        
                        // Sync to master database via API
                        if (APPS_SCRIPT_URL && !checkedInPlayer.isSpecialEvent && !checkedInPlayer.isTeam) {
                            console.log('Syncing Fargo rating update to database:', playerName, fargoId, newRating);
                            fetch(APPS_SCRIPT_URL, {
                                method: 'POST',
                                headers: { 'Content-Type': 'text/plain' },
                                body: JSON.stringify({
                                    action: 'updateFargo',
                                    name: playerName,
                                    fargoId: fargoId,
                                    skill: newRating
                                })
                            })
                            .then(r => r.json())
                            .then(result => {
                                if (result.error) {
                                    console.error('API error updating Fargo:', result.error);
                                } else {
                                    console.log('Fargo rating synced to database:', result);
                                }
                            })
                            .catch(err => console.log('Could not sync Fargo update:', err));
                        }
                        
                        if (oldRating && oldRating !== newRating) {
                            showToast(`${playerName}: Fargo updated ${oldRating} ‚Üí ${newRating}`, 'info');
                        }
                    }
                }
            }
        } catch (error) {
            console.log('Auto-refresh Fargo failed (non-critical):', error.message);
        }
    }
    
    function addNewPlayerQuick(name) {
        const hasPaid = document.getElementById('newPlayerPaid')?.checked ?? false;
        const inSidePot = document.getElementById('newPlayerSidepot')?.checked ?? false;
        const isLate = document.getElementById('newPlayerLate')?.checked ?? false;
        
        // Store for FargoRate lookup
        state.pendingNewPlayer = {
            name: name.trim(),
            phone: '',
            hasPaid: hasPaid,
            inSidePot: inSidePot,
            isLate: isLate
        };
        
        // Hide autocomplete
        const list = document.getElementById('inlineAutocompleteList');
        if (list) list.classList.remove('show');
        
        // Show FargoRate search
        document.getElementById('fargoSearchInput').value = name;
        document.getElementById('fargoResultsList').innerHTML = '';
        document.getElementById('fargoModal').classList.add('show');
        
        searchFargo();
    }
    
    function togglePaid(playerId) {
        const player = state.checkedInPlayers.find(p => p.id === playerId);
        if (player) {
            player.hasPaid = !player.hasPaid;
            saveToLocalStorage();
            updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
        }
    }
    
    function toggleLate(playerId) {
        const player = state.checkedInPlayers.find(p => p.id === playerId);
        if (player) {
            player.isLate = !player.isLate;
            saveToLocalStorage();
            updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
        }
    }
    
    function updateTournamentSettings() {
        state.settings.entryFee = parseFloat(document.getElementById('entryFeeInput').value) || 15;
        state.settings.sidepotAmount = parseFloat(document.getElementById('sidepotInput').value) || 5;
        state.settings.addedMoney = parseFloat(document.getElementById('addedMoneyInput').value) || 0;
        saveToLocalStorage();
        updateSummaryCards();
        updatePayoutsDisplay();
    }
    
    // ============================================================================
    // PAYOUTS DISPLAY
    // ============================================================================
    
    function updatePayoutsDisplay() {
        const container = document.getElementById('payoutsDisplay');
        const totalDisplay = document.getElementById('payoutTotal');
        if (!container) return;
        
        const paidPlayers = state.checkedInPlayers.filter(p => p.hasPaid).length;
        const latePlayers = state.checkedInPlayers.filter(p => p.isLate && !p.hasPaid).length;
        const totalPlayersForPayout = paidPlayers + latePlayers;
        const entryFee = state.settings.entryFee;
        const collectedPool = paidPlayers * entryFee;
        const expectedPool = totalPlayersForPayout * entryFee;
        
        if (totalDisplay) {
            if (latePlayers > 0) {
                totalDisplay.textContent = `$${collectedPool} collected ($${expectedPool} expected)`;
            } else {
                totalDisplay.textContent = `$${collectedPool} Prize Pool`;
            }
        }
        
        if (totalPlayersForPayout < 4) {
            container.innerHTML = `
                <div class="payout-placeholder">
                    Need at least 4 players for payouts (${paidPlayers} paid${latePlayers > 0 ? ` + ${latePlayers} late` : ''})
                </div>
            `;
            return;
        }
        
        // Calculate payouts based on total expected players
        const addedMoney = (state.eventType === 'special') ? (state.settings.addedMoney || 0) : 0;
        const calculator = new TournamentPayoutCalculator(entryFee, totalPlayersForPayout, addedMoney);
        const payouts = calculator.getFormattedPayouts();
        
        if (payouts.error) {
            container.innerHTML = `<div class="payout-placeholder">${payouts.error}</div>`;
            return;
        }
        
        // Render payout items
        let html = '';
        const placeClasses = {
            '1st': 'first-place',
            '2nd': 'second-place',
            '3rd': 'third-place'
        };
        
        Object.entries(payouts).forEach(([place, amount]) => {
            const placeClass = placeClasses[place] || '';
            html += `
                <div class="payout-item ${placeClass}">
                    <div class="payout-place">${place}</div>
                    <div class="payout-amount">$${amount.toFixed(0)}</div>
                </div>
            `;
        });
        
        container.innerHTML = html;
    }
    
    function renderSidepotList() {
        const container = document.getElementById('sidepotPlayerList');
        
        if (state.checkedInPlayers.length === 0) {
            container.innerHTML = '<div class="loading">No players checked in yet</div>';
            return;
        }
        
        container.innerHTML = state.checkedInPlayers.map(player => `
            <div class="player-row ${player.inSidePot ? 'checked-in' : ''}">
                <input type="checkbox" class="player-checkbox" 
                       ${player.inSidePot ? 'checked' : ''} 
                       onchange="toggleSidePot(${player.id})">
                <div class="player-info">
                    <div class="player-name">${player.name}</div>
                </div>
                ${player.inSidePot ? '<span style="color:var(--success);font-weight:bold;">‚úì IN</span>' : ''}
            </div>
        `).join('');
    }
    
    function renderCalcuttaTable() {
        const tbody = document.getElementById('calcuttaTableBody');
        const players = getSortedCalcuttaPlayers();
        const showSkill = state.settings.showSkillLevel;
        
        if (players.length === 0) {
            tbody.innerHTML = '<tr><td colspan="5" style="text-align:center;padding:20px;">No paid or late players to auction</td></tr>';
            return;
        }
        
        // Separate pool players (to show at end)
        const regularPlayers = players.filter(p => !isPoolBuyer(p.calcuttaBuyer));
        const poolPlayers = players.filter(p => isPoolBuyer(p.calcuttaBuyer));
        const allPlayers = [...regularPlayers, ...poolPlayers];
        
        let html = allPlayers.map((player, index) => {
            const isPool = isPoolBuyer(player.calcuttaBuyer);
            const isSelf = player.calcuttaBuyer === player.name;
            const rowClass = isPool ? 'pool-row' : '';
            
            return `
            <tr class="${rowClass}">
                <td>
                    <div class="player-name">${player.name}</div>
                </td>
                <td>
                    ${showSkill ? `
                        <input type="number" 
                               class="skill-input ${player.skill ? '' : 'no-skill'}"
                               value="${player.skill || ''}" 
                               placeholder="-"
                               min="0" max="900" step="1"
                               onchange="updatePlayerSkill(${player.id}, this.value)"
                               style="width:60px; text-align:center;">
                    ` : '-'}
                </td>
                <td style="text-align:center;">
                    <input type="checkbox" class="player-checkbox"
                           ${isSelf ? 'checked' : ''}
                           ${isPool ? 'disabled' : ''}
                           onchange="toggleSelfBuyer(${player.id}, '${escapeForJs(player.name)}')">
                </td>
                <td>
                    <div class="buyer-autocomplete-wrapper">
                        <input type="text" 
                               id="buyerInput_${player.id}"
                               value="${escapeHtml(player.calcuttaBuyer || '')}" 
                               placeholder="Buyer name"
                               ${isSelf ? 'readonly style="background:#f0fdf4;"' : ''}
                               oninput="handleBuyerSearch(${player.id}, this.value)"
                               onchange="updateCalcuttaBuyer(${player.id}, this.value)"
                               onblur="setTimeout(() => hideBuyerAutocomplete(${player.id}), 200)"
                               autocomplete="off">
                        <div class="buyer-autocomplete-list" id="buyerList_${player.id}"></div>
                    </div>
                </td>
                <td>
                    <input type="number" value="${isPool ? '0' : (player.calcuttaBid || '')}" 
                           placeholder="$0"
                           min="0" step="5"
                           ${isPool ? 'disabled' : ''}
                           onchange="updateCalcuttaBid(${player.id}, this.value)">
                </td>
            </tr>
        `}).join('');
        
        // Add Pool auction row at end if there are pooled players
        if (poolPlayers.length > 0) {
            const poolBid = state.poolAuction.bid || 0;
            
            html += `
                <tr class="pool-auction-row" style="background:#fef3c7; border-top:3px solid #f59e0b;">
                    <td>
                        <div class="player-name" style="font-weight:600;">üé± Pool</div>
                        <small style="color:#92400e;">${poolPlayers.length} player${poolPlayers.length > 1 ? 's' : ''}: ${poolPlayers.map(p => p.name.split(' ')[0]).join(', ')}</small>
                    </td>
                    <td style="text-align:center;">-</td>
                    <td style="text-align:center;">-</td>
                    <td>
                        <div class="buyer-autocomplete-wrapper">
                            <input type="text" 
                                   id="poolBuyerInput"
                                   value="${state.poolAuction.buyer || ''}" 
                                   placeholder="Pool buyer"
                                   oninput="handlePoolBuyerSearch(this.value)"
                                   onchange="updatePoolBuyer(this.value)"
                                   onblur="setTimeout(() => hidePoolBuyerAutocomplete(), 200)"
                                   autocomplete="off">
                            <div class="buyer-autocomplete-list" id="poolBuyerList"></div>
                        </div>
                    </td>
                    <td>
                        <input type="number" value="${poolBid || ''}" 
                               placeholder="$0"
                               min="0" step="5"
                               onchange="updatePoolBid(this.value)">
                    </td>
                </tr>
            `;
        }
        
        tbody.innerHTML = html;
    }
    
    // Pool auction functions
    function handlePoolBuyerSearch(query) {
        const list = document.getElementById('poolBuyerList');
        
        if (query.length < 1) {
            list.classList.remove('show');
            list.style.display = 'none';
            return;
        }
        
        // Get all unique names from buyers and players
        const existingBuyers = [...new Set(state.checkedInPlayers
            .map(p => p.calcuttaBuyer)
            .filter(b => b && b.trim() && !isPoolBuyer(b))
        )];
        
        const allNames = [...new Set([
            ...state.masterPlayers.map(p => p.name),
            ...state.checkedInPlayers.map(p => p.name),
            ...existingBuyers
        ])];
        
        const matches = allNames.filter(name => 
            name.toLowerCase().includes(query.toLowerCase())
        ).slice(0, 8);
        
        // Use mousedown instead of onclick (fires before blur)
        let html = matches.map(name => `
            <div class="buyer-option" onmousedown="event.preventDefault(); selectPoolBuyer('${escapeForJs(name)}')">${escapeHtml(name)}</div>
        `).join('');
        
        if (!matches.some(m => m.toLowerCase() === query.toLowerCase())) {
            html += `<div class="buyer-option free-entry" onmousedown="event.preventDefault(); selectPoolBuyer('${escapeForJs(query)}')">
                Add "${escapeHtml(query)}" as new buyer
            </div>`;
        }
        
        list.innerHTML = html;
        list.classList.add('show');
        list.style.display = 'block';
    }
    
    function hidePoolBuyerAutocomplete() {
        const list = document.getElementById('poolBuyerList');
        if (list) {
            list.classList.remove('show');
            list.style.display = 'none';
        }
    }
    
    function selectPoolBuyer(buyerName) {
        console.log('selectPoolBuyer called:', buyerName);
        const input = document.getElementById('poolBuyerInput');
        if (input) {
            input.value = buyerName;
        }
        hidePoolBuyerAutocomplete();
        updatePoolBuyer(buyerName);
    }
    
    function updatePoolBuyer(buyer) {
        state.poolAuction.buyer = buyer;
        saveToLocalStorage();
        updateCalcuttaSummary();
        updateBuyersSummary();
    }
    
    function updatePoolBid(bid) {
        state.poolAuction.bid = parseFloat(bid) || 0;
        saveToLocalStorage();
        renderCalcuttaTable();
        updateCalcuttaSummary();
        updateBuyersSummary();
    }
    
    function togglePoolPaid() {
        state.poolAuction.paid = !state.poolAuction.paid;
        saveToLocalStorage();
        updateCalcuttaSummary();
        updateBuyersSummary();
        renderCalcuttaTable();
    }
    
    // Check if buyer is "Pool" (case insensitive)
    function isPoolBuyer(buyer) {
        return buyer && buyer.toLowerCase().trim() === 'pool';
    }
    
    // Update player's skill rating manually
    function updatePlayerSkill(playerId, skill) {
        const player = state.checkedInPlayers.find(p => p.id === playerId);
        if (player) {
            player.skill = skill ? parseInt(skill) : null;
            
            // Also update in master list
            const masterPlayer = state.masterPlayers.find(p => 
                p.name.toLowerCase() === player.name.toLowerCase() || p.id === player.originalId
            );
            if (masterPlayer) {
                masterPlayer.skill = player.skill;
            }
            
            saveToLocalStorage();
        }
    }
    
    // ============================================================================
    // BUYER AUTOCOMPLETE
    // ============================================================================
    
    function handleBuyerSearch(playerId, query) {
        const list = document.getElementById('buyerList_' + playerId);
        
        if (query.length < 1) {
            list.classList.remove('show');
            list.style.display = 'none';
            return;
        }
        
        // Get all unique names: master players + checked-in players + existing buyers
        const existingBuyers = [...new Set(state.checkedInPlayers
            .map(p => p.calcuttaBuyer)
            .filter(b => b && b.trim())
        )];
        
        const allNames = [...new Set([
            ...state.masterPlayers.map(p => p.name),
            ...state.checkedInPlayers.map(p => p.name),
            ...existingBuyers
        ])];
        
        // Filter by query
        const matches = allNames.filter(name => 
            name.toLowerCase().includes(query.toLowerCase())
        ).slice(0, 8);
        
        // Build options - use mousedown instead of onclick (fires before blur)
        let html = matches.map(name => `
            <div class="buyer-option" onmousedown="event.preventDefault(); selectBuyer(${playerId}, '${escapeForJs(name)}')">${escapeHtml(name)}</div>
        `).join('');
        
        // Add free entry option if query doesn't match exactly
        if (!matches.some(m => m.toLowerCase() === query.toLowerCase())) {
            html += `<div class="buyer-option free-entry" onmousedown="event.preventDefault(); selectBuyer(${playerId}, '${escapeForJs(query)}')">
                Add "${escapeHtml(query)}" as new buyer
            </div>`;
        }
        
        list.innerHTML = html;
        list.classList.add('show');
        list.style.display = 'block';
    }
    
    function selectBuyer(playerId, buyerName) {
        console.log('selectBuyer called:', playerId, buyerName);
        const input = document.getElementById('buyerInput_' + playerId);
        const list = document.getElementById('buyerList_' + playerId);
        
        // First update the input value directly
        if (input) {
            input.value = buyerName;
            console.log('Set input value to:', buyerName);
        } else {
            console.error('Could not find buyerInput_' + playerId);
            return;
        }
        
        // Hide the dropdown
        if (list) {
            list.classList.remove('show');
            list.style.display = 'none';
        }
        
        // Update player data
        updateCalcuttaBuyer(playerId, buyerName);
    }
    
    function hideBuyerAutocomplete(playerId) {
        const list = document.getElementById('buyerList_' + playerId);
        if (list) {
            list.classList.remove('show');
            list.style.display = 'none';
        }
    }
    
    function updateBuyersSummary() {
        const container = document.getElementById('buyerSummaryList');
        const buyers = getBuyersSummary();
        
        if (buyers.length === 0) {
            container.innerHTML = '<div class="loading">No calcutta bids entered yet</div>';
            document.getElementById('totalBuyers').textContent = '0';
            document.getElementById('totalOwed').textContent = '$0';
            document.getElementById('unpaidBuyers').textContent = '0';
            document.getElementById('unpaidCount').textContent = '0';
            document.getElementById("calcuttaPlacesPaid").textContent = "0";
            document.getElementById("calcuttaPayoutsList").innerHTML = "";
            return;
        }
        
        container.innerHTML = buyers.map(buyer => `
            <div class="buyer-row ${buyer.paid ? 'paid' : 'unpaid'}">
                <input type="checkbox" class="player-checkbox"
                       ${buyer.paid ? 'checked' : ''}
                       onchange="toggleBuyerPaid('${buyer.name.replace(/'/g, "\\'")}')">
                <div class="buyer-name">
                    <div>${buyer.name}</div>
                    <div style="font-size:0.8rem;color:var(--text-light);">${buyer.players.join(', ')}</div>
                </div>
                <div class="buyer-amount">$${buyer.totalOwed.toFixed(0)}</div>
            </div>
        `).join('');
        
        const totalOwed = buyers.reduce((sum, b) => sum + b.totalOwed, 0);
        const unpaidBuyers = buyers.filter(b => !b.paid);
        
        document.getElementById('totalBuyers').textContent = buyers.length;
        document.getElementById('totalOwed').textContent = '$' + totalOwed.toFixed(0);
        document.getElementById('unpaidBuyers').textContent = unpaidBuyers.length;
        document.getElementById('unpaidCount').textContent = unpaidBuyers.length || '';

        // Calculate and display Calcutta payouts
        const playerCount = state.checkedInPlayers.length;
        const calculator = new CalcuttaPayoutCalculator(totalOwed, playerCount);
        const { placesToPay, payouts } = calculator.getFormattedPayouts();

        const placesPaidEl = document.getElementById("calcuttaPlacesPaid");
        const payoutsListEl = document.getElementById("calcuttaPayoutsList");

        if (placesPaidEl) placesPaidEl.textContent = placesToPay;
        if (payoutsListEl) {
            if (payouts.length === 0) {
                payoutsListEl.innerHTML = "";
            } else {
                payoutsListEl.innerHTML = payouts.map(p => 
                    `<div style="display:flex;justify-content:space-between;padding:2px 0;border-bottom:1px solid rgba(255,255,255,0.2);">
                        <span>${p.place}</span>
                        <span style="font-weight:700;">$${p.amount}</span>
                    </div>`
                ).join("");
            }
        }
    }
    
    function updateCalcuttaSummary() {
        // Only count bids from paid or late players (those visible in Calcutta)
        const eligiblePlayers = state.checkedInPlayers.filter(p => p.hasPaid || p.isLate);
        
        // Sum regular bids (not pool players)
        const regularBids = eligiblePlayers
            .filter(p => !isPoolBuyer(p.calcuttaBuyer))
            .reduce((sum, p) => sum + (p.calcuttaBid || 0), 0);
        
        // Add pool bid
        const poolBid = state.poolAuction.bid || 0;
        const totalBids = regularBids + poolBid;
        
        // Calculate unpaid
        const unpaidRegular = eligiblePlayers
            .filter(p => p.calcuttaBid > 0 && !p.calcuttaPaid && !isPoolBuyer(p.calcuttaBuyer))
            .reduce((sum, p) => sum + p.calcuttaBid, 0);
        const unpaidPool = (poolBid > 0 && !state.poolAuction.paid) ? poolBid : 0;
        const unpaidBids = unpaidRegular + unpaidPool;
        
        document.getElementById('calcuttaTotal').textContent = '$' + totalBids.toFixed(0);
        document.getElementById('calcuttaUnpaid').textContent = '$' + unpaidBids.toFixed(0);
    }
    
    function updateSummaryCards() {
        const checkedIn = state.checkedInPlayers.length;
        const paidPlayers = state.checkedInPlayers.filter(p => p.hasPaid);
        const latePlayers = state.checkedInPlayers.filter(p => p.isLate && !p.hasPaid);
        const unpaidPlayers = state.checkedInPlayers.filter(p => !p.hasPaid && !p.isLate);
        const sidepotPlayers = state.checkedInPlayers.filter(p => p.inSidePot);
        
        const entryCollected = paidPlayers.length * state.settings.entryFee;
        const sidepotTotal = sidepotPlayers.length * state.settings.sidepotAmount;
        
        // Update check-in tab cards
        const totalPlayersEl = document.getElementById('totalPlayers');
        const totalCollectedEl = document.getElementById('totalCollected');
        const sidepotCollectedEl = document.getElementById('sidepotCollected');
        const unpaidEntriesEl = document.getElementById('unpaidEntries');
        
        // Show total players including late
        if (totalPlayersEl) {
            if (latePlayers.length > 0) {
                totalPlayersEl.innerHTML = `${paidPlayers.length} <small style="font-size:0.6em;opacity:0.8;">+${latePlayers.length} late</small>`;
            } else {
                totalPlayersEl.textContent = checkedIn;
            }
        }
        if (totalCollectedEl) totalCollectedEl.textContent = '$' + entryCollected;
        if (sidepotCollectedEl) sidepotCollectedEl.textContent = '$' + sidepotTotal;
        if (unpaidEntriesEl) unpaidEntriesEl.textContent = unpaidPlayers.length;
        
        // Update side pot tab cards
        const sidepotPlayersEl = document.getElementById('sidepotPlayers');
        const sidepotTotalEl = document.getElementById('sidepotTotal');
        const sidepotAmountDisplayEl = document.getElementById('sidepotAmountDisplay');
        
        if (sidepotPlayersEl) sidepotPlayersEl.textContent = sidepotPlayers.length;
        if (sidepotTotalEl) sidepotTotalEl.textContent = '$' + sidepotTotal;
        if (sidepotAmountDisplayEl) sidepotAmountDisplayEl.textContent = state.settings.sidepotAmount;
        

        // Update sidepot payouts display
        updateSidepotPayoutsDisplay();
        // Update calcutta summary
        updateCalcuttaSummary();
    }
    
    // Download CSV of paid and late players
function downloadPlayersCSV() {
    // Get paid and late players
    const eligiblePlayers = state.checkedInPlayers.filter(p => p.hasPaid || p.isLate);
    
    if (eligiblePlayers.length === 0) {
        showToast('No paid or late players to export', 'error');
        return;
    }
    
    // Sort by skill level (highest to lowest)
    eligiblePlayers.sort((a, b) => (b.skill || 0) - (a.skill || 0));
    
    // Build CSV content - added Fargo_ID column
    let csv = 'name,phone_number,skill_level,Fargo_ID\n';
    
    eligiblePlayers.forEach(player => {
        const name = player.name || '';
        // Extract just digits from phone number
        const phoneDigits = (player.phone || '').replace(/\D/g, '');
        const skill = player.skill || '';
        const fargoId = player.fargoId || '';
        
        // Escape name if it contains commas
        const escapedName = name.includes(',') ? `"${name}"` : name;
        
        csv += `${escapedName},${phoneDigits},${skill},${fargoId}\n`;
    });
    
    // Create and trigger download
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    
    // Generate filename with date
    const now = new Date();
    const dateStr = now.toISOString().split('T')[0];
    const filename = `tournament_players_${dateStr}.csv`;
    
    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    showToast(`Downloaded ${eligiblePlayers.length} players to CSV`, 'success');
    
    // Stop calcutta live display if it's running
    if (state.calcuttaActive) {
        state.calcuttaActive = false;
        updateCalcuttaActiveUI();
        saveTournamentData();
        showToast('Calcutta live display stopped', 'info');
    }
    
    // Schedule GitHub workflow trigger for 10 minutes from now
    scheduleWorkflowTrigger();
}
    
    // Schedule the GitHub Actions workflow to run after 10 minutes
    let workflowTimerId = null;
    
    function scheduleWorkflowTrigger() {
        // Cancel any existing scheduled trigger
        if (workflowTimerId) {
            clearTimeout(workflowTimerId);
            console.log('Cancelled previous workflow timer');
        }
        
        const delayMinutes = 10;
        const delayMs = delayMinutes * 60 * 1000;
        
        // Calculate trigger time for display
        const triggerTime = new Date(Date.now() + delayMs);
        const timeStr = triggerTime.toLocaleTimeString();
        
        console.log(`Workflow scheduled to trigger at ${timeStr} (in ${delayMinutes} minutes)`);
        showToast(`Display update scheduled for ${timeStr}`, 'info');
        
        workflowTimerId = setTimeout(async () => {
            console.log('Timer fired - triggering GitHub workflow...');
            await triggerGitHubWorkflow();
            workflowTimerId = null;
        }, delayMs);
    }
    
    // Trigger the GitHub Actions workflow via server-side script
async function triggerGitHubWorkflow() {
    const url = GITHUB_CONFIG.triggerEndpoint;
    
    try {
        console.log('Triggering GitHub workflow via server:', url);
        
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        const result = await response.json();
        
        if (result.success) {
            console.log('GitHub workflow triggered successfully!');
            showToast('Tournament display update triggered!', 'success');
            return true;
        } else {
            console.error('Workflow trigger failed:', result.error);
            showToast('Failed: ' + result.error, 'error');
            return false;
        }
    } catch (error) {
        console.error('Error triggering GitHub workflow:', error);
        showToast('Error triggering workflow', 'error');
        return false;
    }
}
    
    // Manual trigger function (can be called from console)
    window.triggerWorkflowNow = async function() {
        console.log('Manual workflow trigger requested');
        return await triggerGitHubWorkflow();
    };
    
    // Cancel scheduled workflow
    window.cancelScheduledWorkflow = function() {
        if (workflowTimerId) {
            clearTimeout(workflowTimerId);
            workflowTimerId = null;
            console.log('Scheduled workflow cancelled');
            showToast('Scheduled update cancelled', 'info');
        } else {
            console.log('No workflow scheduled');
        }
    };
    
    // Link existing player to FargoRate
    function linkToFargo(playerId) {
        const player = state.checkedInPlayers.find(p => p.id === playerId);
        if (!player) return;
        
        state.pendingNewPlayer = {
            existingPlayerId: playerId,
            name: player.name,
            phone: player.phone
        };
        
        document.getElementById('fargoSearchInput').value = player.name;
        document.getElementById('fargoResultsList').innerHTML = '';
        document.getElementById('fargoModal').classList.add('show');
        
        searchFargo();
    }
    
    function updateBadges() {
        const checkinBadge = document.getElementById('checkinCount');
        const sidepotBadge = document.getElementById('sidepotCount');
        const unpaidBadge = document.getElementById('unpaidCount');
        
        const paidCount = state.checkedInPlayers.filter(p => p.hasPaid).length;
        const sidepotCount = state.checkedInPlayers.filter(p => p.inSidePot).length;
        const unpaidBuyers = getBuyersSummary().filter(b => !b.paid).length;
        
        if (checkinBadge) checkinBadge.textContent = paidCount || '';
        if (sidepotBadge) sidepotBadge.textContent = sidepotCount || '';
        if (unpaidBadge) unpaidBadge.textContent = unpaidBuyers || '';
    }
    
    // ============================================================================
    // SETTINGS
    // ============================================================================
    
    function updateSettings() {
        // Get from check-in tab settings if available
        const entryFeeInput = document.getElementById('entryFeeInput');
        const sidepotInput = document.getElementById('sidepotInput');
        const showSkillLevel = document.getElementById('showSkillLevel');
        
        if (entryFeeInput) {
            state.settings.entryFee = parseFloat(entryFeeInput.value) || 15;
        }
        if (sidepotInput) {
            state.settings.sidepotAmount = parseFloat(sidepotInput.value) || 5;
        }
        if (showSkillLevel) {
            state.settings.showSkillLevel = showSkillLevel.checked;
        }
        
        saveToLocalStorage();
        updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
    }
    
    function saveDataSources() {
        // Save data source settings
        localStorage.setItem('masterDbUrl', document.getElementById('masterDbUrl').value);
        localStorage.setItem('mainWorkbookUrl', document.getElementById('mainWorkbookUrl').value);
        showToast('Data sources saved', 'success');
    }
    
    // ============================================================================
    // EXPORT
    // ============================================================================
    
    async function exportToSheet() {
        const exportData = {
            action: 'exportToSheet',
            eventType: state.eventType,
            specialEventId: state.specialEventUrl ? state.specialEventUrl.match(/\/d\/([a-zA-Z0-9-_]+)/)?.[1] : null,
            timestamp: new Date().toISOString(),
            settings: state.settings,
            players: state.checkedInPlayers.map(p => ({
                name: p.name,
                phone: p.phone,
                skill: p.skill,
                inSidePot: p.inSidePot,
                calcuttaBuyer: p.calcuttaBuyer,
                calcuttaBid: p.calcuttaBid,
                calcuttaPaid: p.calcuttaPaid
            })),
            buyerSummary: getBuyersSummary()
        };
        
        console.log('Export data:', exportData);
        
        if (APPS_SCRIPT_URL) {
            try {
                showToast('Exporting to Google Sheet...', 'info');
                
                const response = await fetch(APPS_SCRIPT_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'text/plain',
                    },
                    body: JSON.stringify(exportData)
                });
                
                const result = await response.json();
                
                if (result.error) {
                    throw new Error(result.error);
                }
                
                showToast('Data exported successfully!', 'success');
            } catch (error) {
                console.error('Export error:', error);
                showToast('Export failed: ' + error.message, 'error');
            }
        } else {
            // No API configured - just log data
            showToast('Export data logged to console (configure API URL for Google Sheets)', 'info');
        }
    }
    
    function clearAllData() {
        if (confirm('Clear all data for the current tournament? This cannot be undone.\n\nNote: Other saved tournaments will not be affected.')) {
            state.checkedInPlayers = [];
            state.poolAuction = { buyer: '', bid: 0, paid: false };
            
            // Also clear the tournament-specific saved data
            clearTournamentData();
            
            saveToLocalStorage();
            updateAllDisplays();

        // Auto-detect today's tournament on load
        autoDetectTodaysTournament();
            showToast('Tournament data cleared', 'success');
        }
    }
    
    // Clear ALL saved tournament data (use with caution)
    window.clearAllSavedTournaments = function() {
        if (confirm('This will delete ALL saved tournament data. Are you sure?')) {
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('tournamentData_')) {
                    keysToRemove.push(key);
                }
            }
            keysToRemove.forEach(key => localStorage.removeItem(key));
            console.log('Cleared', keysToRemove.length, 'saved tournaments');
            showToast(`Cleared ${keysToRemove.length} saved tournaments`, 'success');
        }
    };
    
    // ============================================================================
    // UI HELPERS
    // ============================================================================
    
    function switchTab(tabId) {
        // Remove active from both old tabs and new sidebar tabs
        document.querySelectorAll('.tab, .sidebar-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        
        // Add active to the correct tab
        const tab = document.querySelector(`[data-tab="${tabId}"]`);
        if (tab) tab.classList.add('active');
        
        const content = document.getElementById('tab-' + tabId);
        if (content) content.classList.add('active');
    }
    
    function closeModal(modalId) {
        document.getElementById(modalId).classList.remove('show');
    }

    // ============================================================================
    // SIDEPOT PAYOUTS MANAGEMENT
    // ============================================================================

    function openSidepotPayoutsModal() {
        const container = document.getElementById("sidepotPayoutsInputs");
        container.innerHTML = "";

        const payouts = state.settings.sidepotPayouts || [];

        if (payouts.length === 0) {
            // Default: add 3 empty rows
            for (let i = 1; i <= 3; i++) {
                addSidepotPayoutRow(i, "");
            }
        } else {
            payouts.forEach((amount, idx) => {
                addSidepotPayoutRow(idx + 1, amount);
            });
        }

        document.getElementById("sidepotPayoutsModal").classList.add("show");
    }

    function addSidepotPayoutRow(place, amount) {
        const container = document.getElementById("sidepotPayoutsInputs");
        const existingRows = container.querySelectorAll(".sidepot-payout-row").length;
        const placeNum = place || existingRows + 1;
        const amountVal = amount || "";

        const row = document.createElement("div");
        row.className = "sidepot-payout-row";
        row.style.cssText = "display: flex; align-items: center; gap: 8px;";
        row.innerHTML = `
            <span style="min-width: 50px; font-weight: 600;">${getPlaceLabel(placeNum)}:</span>
            <div style="display: flex; align-items: center;">
                <span style="margin-right: 4px;">$</span>
                <input type="number" class="form-control sidepot-amount-input" value="${amountVal}" 
                       min="0" step="5" style="width: 100px;" placeholder="0">
            </div>
            <button class="btn btn-small" onclick="this.parentElement.remove()" style="padding: 4px 8px; background: #dc3545; color: white;">√ó</button>
        `;
        container.appendChild(row);
    }

    function getPlaceLabel(place) {
        if (place === 1) return "1st";
        if (place === 2) return "2nd";
        if (place === 3) return "3rd";
        return place + "th";
    }

    function saveSidepotPayouts() {
        const inputs = document.querySelectorAll(".sidepot-amount-input");
        const payouts = [];

        inputs.forEach(input => {
            const val = parseFloat(input.value) || 0;
            payouts.push(val);
        });

        // Remove trailing zeros
        while (payouts.length > 0 && payouts[payouts.length - 1] === 0) {
            payouts.pop();
        }

        state.settings.sidepotPayouts = payouts;
        saveTournamentData();
        updateSidepotPayoutsDisplay();
        closeModal("sidepotPayoutsModal");
        showToast("Side pot payouts saved!", "success");
    }

    function updateSidepotPayoutsDisplay() {
        const payouts = state.settings.sidepotPayouts || [];
        const placesPaidEl = document.getElementById("sidepotPlacesPaid");
        const payoutsListEl = document.getElementById("sidepotPayoutsList");

        const validPayouts = payouts.filter(p => p > 0);

        if (placesPaidEl) placesPaidEl.textContent = validPayouts.length;

        if (payoutsListEl) {
            if (validPayouts.length === 0) {
                payoutsListEl.innerHTML = "<div style='opacity:0.7; font-size:0.8rem;'>Click Edit to set</div>";
            } else {
                payoutsListEl.innerHTML = payouts.map((amt, idx) => {
                    if (amt <= 0) return "";
                    return `<div style="display:flex;justify-content:space-between;padding:2px 0;border-bottom:1px solid rgba(255,255,255,0.2);">
                        <span>${getPlaceLabel(idx + 1)}</span>
                        <span style="font-weight:700;">$${amt}</span>
                    </div>`;
                }).join("");
            }
        }
    }
    
    function showLoading(containerId) {
        const container = document.getElementById(containerId);
        if (container) {
            container.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    Loading...
                </div>
            `;
        }
        // Also show a toast for visibility
        console.log('Loading...');
    }
    
    function showToast(message, type = 'info') {
        const container = document.getElementById('toastContainer');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        container.appendChild(toast);
        
        setTimeout(() => {
            toast.remove();
        }, 3000);
    }
    
    // Close autocomplete when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.autocomplete-wrapper')) {
            const list = document.getElementById('autocompleteList');
            if (list) list.classList.remove('show');
        }
        if (!e.target.closest('.inline-autocomplete')) {
            const list = document.getElementById('inlineAutocompleteList');
            if (list) list.classList.remove('show');
        }
    });
    
    // Close modals when clicking overlay
    document.querySelectorAll('.modal-overlay').forEach(overlay => {
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                overlay.classList.remove('show');
            }
        });
    });
    
    // ============================================================================
    // CALCUTTA LIVE DISPLAY FUNCTIONS
    // ============================================================================
    
    function toggleCalcuttaActive() {
        state.calcuttaActive = !state.calcuttaActive;
        updateCalcuttaActiveUI();
        saveTournamentData();
        
        if (state.calcuttaActive) {
            showToast('Calcutta auction is now LIVE on TV display!', 'success');
        } else {
            showToast('Calcutta auction display stopped', 'info');
        }
    }
    
    function updateCalcuttaActiveUI() {
        const btn = document.getElementById('startCalcuttaBtn');
        const statusText = document.getElementById('calcuttaStatusText');
        const calcuttaBodyEl = document.getElementById('calcuttaBody');
        
        if (!btn || !statusText || !calcuttaBodyEl) return;
        
        if (state.calcuttaActive) {
            btn.textContent = '‚èπÔ∏è Stop Calcutta';
            btn.classList.add('active');
            statusText.textContent = 'LIVE - Auction is being displayed on TV';
            statusText.classList.add('active');
            calcuttaBodyEl.classList.remove('calcutta-disabled');
        } else {
            btn.textContent = 'üéØ Start Calcutta';
            btn.classList.remove('active');
            statusText.textContent = 'Click to start the live auction display';
            statusText.classList.remove('active');
            calcuttaBodyEl.classList.add('calcutta-disabled');
        }
    }
    </script>
</body>
</html>
