<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bankshot Calcutta</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Oswald:wght@400;600;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Roboto', Arial, sans-serif;
            background: linear-gradient(180deg, #1a472a 0%, #0d3320 100%);
            height: 100vh;
            color: #1f2937;
            overflow: hidden;
        }
        
        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px 40px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 15px;
            flex-shrink: 0;
        }
        
        .tournament-name {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 3.5rem;
            color: #ffffff;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            letter-spacing: 3px;
            margin-bottom: 5px;
        }
        
        .page-title {
            font-family: 'Oswald', sans-serif;
            font-size: 2.5rem;
            color: #ffd700;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            letter-spacing: 4px;
            text-transform: uppercase;
        }
        
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 15px;
            flex-shrink: 0;
        }
        
        .summary-card {
            background: linear-gradient(135deg, #1e7e34 0%, #0d5c26 100%);
            color: white;
            padding: 12px 15px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .summary-card.gold {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }
        
        .summary-card.blue {
            background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
        }
        
        .summary-card.purple {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
        }
        
        .summary-value {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 3rem;
            line-height: 1;
        }
        
        .summary-label {
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            opacity: 0.9;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Payouts display in card */
        .payouts-list {
            font-family: 'Roboto', sans-serif;
            font-size: 0.9rem;
            margin-top: 8px;
            text-align: left;
            padding: 0 5px;
        }
        
        .payout-row {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
        
        .payout-row:last-child {
            border-bottom: none;
        }
        
        .payout-place {
            font-weight: 500;
        }
        
        .payout-amount {
            font-weight: 700;
        }
        
        .main-card {
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }
        
        .card-header {
            background: linear-gradient(135deg, #1e7e34 0%, #0d5c26 100%);
            color: white;
            padding: 12px 25px;
            font-family: 'Oswald', sans-serif;
            font-size: 1.3rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .scroll-wrapper {
            flex: 1;
            overflow: hidden;
            position: relative;
        }
        
        .buyer-list {
            position: absolute;
            width: 100%;
            will-change: transform;
        }
        
        .buyer-list.scrolling {
            animation: scrollUp linear infinite;
        }
        
        @keyframes scrollUp {
            0% { transform: translateY(0); }
            100% { transform: translateY(-50%); }
        }
        
        .buyer-row {
            display: grid;
            grid-template-columns: 1fr 2fr 150px 100px;
            align-items: center;
            padding: 14px 25px;
            border-bottom: 1px solid #e5e7eb;
            gap: 15px;
        }
        
        .buyer-row:nth-child(even) {
            background: #f9fafb;
        }
        
        .buyer-row.paid {
            border-left: 5px solid #10b981;
        }
        
        .buyer-row.unpaid {
            border-left: 5px solid #f59e0b;
            background: #fffbeb;
        }
        
        .buyer-row.unpaid:nth-child(even) {
            background: #fef3c7;
        }
        
        .buyer-row.pool-row {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            border-left: 5px solid #3b82f6;
        }
        
        .buyer-name {
            font-weight: 600;
            font-size: 1.3rem;
            color: #1f2937;
        }
        
        .buyer-players {
            font-size: 1.1rem;
            color: #4b5563;
        }
        
        .buyer-amount {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2rem;
            color: #1e7e34;
            text-align: right;
        }
        
        .status-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            text-align: center;
        }
        
        .status-badge.paid { background: #10b981; color: white; }
        .status-badge.unpaid { background: #f59e0b; color: white; }
        .status-badge.pool { background: #3b82f6; color: white; }
        
        .no-data {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-size: 1.8rem;
            color: #6b7280;
            font-family: 'Oswald', sans-serif;
        }
        
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-size: 1.5rem;
            color: #6b7280;
        }
        
        @media (min-aspect-ratio: 16/9) {
            .container { padding: 15px 60px; }
            .buyer-row { padding: 16px 30px; }
            .buyer-name { font-size: 1.4rem; }
            .buyer-players { font-size: 1.2rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="tournament-name" id="tournamentName">Tournament</div>
            <div class="page-title">Calcutta Auction</div>
        </div>
        
        <div class="summary-grid">
            <div class="summary-card">
                <div class="summary-value" id="totalBuyers">0</div>
                <div class="summary-label">Buyers</div>
            </div>
            <div class="summary-card gold">
                <div class="summary-value" id="totalAmount">$0</div>
                <div class="summary-label">Total Pot</div>
            </div>
            <div class="summary-card blue">
                <div class="summary-value" id="playerCount">0</div>
                <div class="summary-label">Players Sold</div>
            </div>
            <div class="summary-card purple">
                <div class="summary-value" id="placesToPay">0</div>
                <div class="summary-label">Places Paid</div>
                <div class="payouts-list" id="payoutsList"></div>
            </div>
        </div>
        
        <div class="main-card">
            <div class="card-header">
                <span>Buyer Summary</span>
                <span id="lastUpdated"></span>
            </div>
            <div class="scroll-wrapper">
                <div class="buyer-list" id="buyerList">
                    <div class="loading">Loading calcutta data...</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const tournamentKey = urlParams.get('key');
        const tournamentName = urlParams.get('tournament');
        
        if (tournamentName) {
            document.getElementById('tournamentName').textContent = decodeURIComponent(tournamentName);
        }
        
        // ============================================================================
        // CALCUTTA PAYOUT CALCULATOR (Based on TournamentPayoutCalculator methodology)
        // Pays 10% of field, rounds to $5, uses aggressive bonus model
        // ============================================================================
        
        class CalcuttaPayoutCalculator {
            constructor(totalPot, numPlayers) {
                this.totalPot = totalPot;
                this.numPlayers = numPlayers;
                this.baseAmount = 5; // Minimum rounding unit
            }
            
            roundAmount(amount) {
                let rounded = Math.round(amount / this.baseAmount) * this.baseAmount;
                if (rounded < this.baseAmount) {
                    rounded = this.baseAmount;
                }
                return rounded;
            }
            
            // Pay approximately 10% of field with meaningful tie groups
            getMaxPlaceToPay() {
                const n = this.numPlayers;
                if (n < 10) return 1;                    // 1-9 players: 1st only
                if (n >= 10 && n < 20) return 2;         // 10-19 players: 1st-2nd
                if (n >= 20 && n < 30) return 3;         // 20-29 players: 1st-3rd
                if (n >= 30 && n < 40) return 4;         // 30-39 players: 1st-4th
                if (n >= 40 && n < 60) return 6;         // 40-59 players: 1st-6th (5-6 tie)
                if (n >= 60 && n < 80) return 8;         // 60-79 players: 1st-8th (7-8 tie)
                if (n >= 80 && n < 120) return 12;       // 80-119 players: 1st-12th
                if (n >= 120 && n < 160) return 16;      // 120-159 players: 1st-16th
                if (n >= 160) return 24;                 // 160+ players: 1st-24th
                return 1;
            }
            
            getTieGroups() {
                const maxPlace = this.getMaxPlaceToPay();
                if (maxPlace === 0) return [];
                
                const groups = [];
                
                if (maxPlace >= 1) groups.push({start: 1, end: 1});
                if (maxPlace >= 2) groups.push({start: 2, end: 2});
                if (maxPlace >= 3) groups.push({start: 3, end: 3});
                if (maxPlace >= 4) groups.push({start: 4, end: 4});
                if (maxPlace >= 6) groups.push({start: 5, end: 6});
                if (maxPlace >= 8) groups.push({start: 7, end: 8});
                if (maxPlace >= 12) groups.push({start: 9, end: 12});
                if (maxPlace >= 16) groups.push({start: 13, end: 16});
                if (maxPlace >= 24) groups.push({start: 17, end: 24});
                
                return groups;
            }
            
            calculatePayouts() {
                const groups = this.getTieGroups();
                
                if (groups.length === 0 || this.totalPot < this.baseAmount) {
                    return { error: "Not enough data" };
                }
                
                const maxPlace = groups[groups.length - 1].end;
                const numGroups = groups.length;
                
                // Special case: Only 1st place
                if (maxPlace === 1) {
                    return { 1: this.totalPot };
                }
                
                // Special case: 1st and 2nd place
                if (maxPlace === 2) {
                    const payouts = {};
                    payouts[1] = this.roundAmount(this.totalPot * 0.65);
                    payouts[2] = this.totalPot - payouts[1];
                    return payouts;
                }
                
                // Special case: 1st, 2nd, 3rd
                if (maxPlace === 3) {
                    const payouts = {};
                    payouts[1] = this.roundAmount(this.totalPot * 0.50);
                    payouts[2] = this.roundAmount(this.totalPot * 0.30);
                    payouts[3] = this.totalPot - payouts[1] - payouts[2];
                    return payouts;
                }
                
                // Special case: 4 places - direct percentages
                if (maxPlace === 4) {
                    const payouts = {};
                    payouts[1] = this.roundAmount(this.totalPot * 0.50);
                    payouts[2] = this.roundAmount(this.totalPot * 0.25);
                    payouts[3] = this.roundAmount(this.totalPot * 0.15);
                    payouts[4] = this.roundAmount(this.totalPot * 0.10);
                    
                    // Balance adjustment
                    const total = Object.values(payouts).reduce((a, b) => a + b, 0);
                    payouts[1] += (this.totalPot - total);
                    
                    return payouts;
                }
                
                // For 5+ places: baseline + bonus model
                const minPayout = this.baseAmount;
                const baselinePot = minPayout * maxPlace;
                const bonusPot = this.totalPot - baselinePot;
                
                if (bonusPot <= 0) {
                    // Not enough money - split evenly
                    const perPlace = this.roundAmount(this.totalPot / maxPlace);
                    const payouts = {};
                    for (let i = 1; i <= maxPlace; i++) {
                        payouts[i] = perPlace;
                    }
                    return payouts;
                }
                
                // Calculate bonus weights with aggressive decay
                const weights = [];
                let totalWeight = 0;
                const decayRate = (numGroups > 6) ? 0.45 : 0.5;
                
                for (let i = 0; i < numGroups; i++) {
                    const weight = Math.pow(decayRate, i);
                    weights[i] = weight;
                    totalWeight += weight;
                }
                
                // Distribute bonuses
                const payouts = {};
                
                groups.forEach((group, i) => {
                    const groupSize = group.end - group.start + 1;
                    const bonusShare = (weights[i] / totalWeight) * bonusPot;
                    const bonusPerPlace = bonusShare / groupSize;
                    
                    const totalPayout = minPayout + bonusPerPlace;
                    const rounded = this.roundAmount(totalPayout);
                    
                    for (let place = group.start; place <= group.end; place++) {
                        payouts[place] = rounded;
                    }
                });
                
                // Enforce descending order
                for (let i = 1; i < numGroups; i++) {
                    const currentGroup = groups[i];
                    const previousGroup = groups[i - 1];
                    
                    const currentAmount = payouts[currentGroup.start];
                    const previousAmount = payouts[previousGroup.start];
                    
                    if (currentAmount >= previousAmount) {
                        const newAmount = previousAmount - this.baseAmount;
                        const finalAmount = Math.max(newAmount, this.baseAmount);
                        
                        for (let place = currentGroup.start; place <= currentGroup.end; place++) {
                            payouts[place] = finalAmount;
                        }
                    }
                }
                
                // Final balance adjustment - add remainder to 1st place
                const allocatedTotal = Object.values(payouts).reduce((a, b) => a + b, 0);
                const difference = this.totalPot - allocatedTotal;
                payouts[1] += difference;
                
                return payouts;
            }
            
            getFormattedPayouts() {
                const payouts = this.calculatePayouts();
                const formatted = [];
                
                if (payouts.error) {
                    return { placesToPay: 0, payouts: [] };
                }
                
                const groups = this.getTieGroups();
                const seen = new Set();
                
                groups.forEach(group => {
                    const place = group.start;
                    const amount = payouts[place];
                    
                    let label;
                    if (group.start === group.end) {
                        label = this.getPlaceLabel(place);
                    } else {
                        label = this.getPlaceLabel(group.start) + '-' + this.getPlaceLabel(group.end).replace(/[a-z]+$/, '');
                    }
                    
                    if (!seen.has(label)) {
                        formatted.push({ place: label, amount: amount });
                        seen.add(label);
                    }
                });
                
                return {
                    placesToPay: this.getMaxPlaceToPay(),
                    payouts: formatted
                };
            }
            
            getPlaceLabel(place) {
                if (place === 1) return '1st';
                if (place === 2) return '2nd';
                if (place === 3) return '3rd';
                if (place === 4) return '4th';
                if (place === 5) return '5th';
                if (place === 6) return '6th';
                if (place === 7) return '7th';
                if (place === 8) return '8th';
                if (place === 9) return '9th';
                if (place === 12) return '12th';
                if (place === 16) return '16th';
                if (place === 24) return '24th';
                return place + 'th';
            }
        }
        
        function formatCurrency(value) {
            const numValue = parseFloat(value) || 0;
            return '$' + numValue.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
        }
        
        function aggregateBuyers(players, poolAuction) {
            const buyers = {};
            
            players.forEach(player => {
                const buyer = player.calcuttaBuyer || '';
                const bid = parseFloat(player.calcuttaBid) || 0;
                const paid = player.calcuttaPaid || false;
                const playerName = player.name || 'Unknown';
                
                if (!buyer || bid === 0) return;
                
                const isPool = buyer.toLowerCase() === 'pool';
                
                if (!buyers[buyer]) {
                    buyers[buyer] = {
                        name: buyer,
                        players: [],
                        totalAmount: 0,
                        allPaid: true,
                        isPool: isPool
                    };
                }
                
                buyers[buyer].players.push(playerName);
                buyers[buyer].totalAmount += bid;
                if (!paid) buyers[buyer].allPaid = false;
            });
            
            if (poolAuction && poolAuction.bid > 0 && poolAuction.buyer) {
                const poolBuyer = poolAuction.buyer;
                if (!buyers[poolBuyer]) {
                    buyers[poolBuyer] = {
                        name: poolBuyer,
                        players: [],
                        totalAmount: 0,
                        allPaid: true,
                        isPool: false
                    };
                }
                buyers[poolBuyer].players.push('ðŸŽ± The Pool');
                buyers[poolBuyer].totalAmount += parseFloat(poolAuction.bid) || 0;
                if (!poolAuction.paid) buyers[poolBuyer].allPaid = false;
            }
            
            return Object.values(buyers).sort((a, b) => b.totalAmount - a.totalAmount);
        }
        
        function renderBuyers(buyers, playerCount) {
            const container = document.getElementById('buyerList');
            
            if (!buyers || buyers.length === 0) {
                container.innerHTML = '<div class="no-data">No calcutta data yet</div>';
                document.getElementById('totalBuyers').textContent = '0';
                document.getElementById('totalAmount').textContent = '$0';
                document.getElementById('playerCount').textContent = '0';
                document.getElementById('placesToPay').textContent = '0';
                document.getElementById('payoutsList').innerHTML = '';
                return false;
            }
            
            document.getElementById('totalBuyers').textContent = buyers.length;
            const totalAmount = buyers.reduce((sum, b) => sum + b.totalAmount, 0);
            document.getElementById('totalAmount').textContent = formatCurrency(totalAmount);
            const totalPlayers = buyers.reduce((sum, b) => sum + b.players.length, 0);
            document.getElementById('playerCount').textContent = totalPlayers;
            
            // Calculate and display payouts using CalcuttaPayoutCalculator
            const calculator = new CalcuttaPayoutCalculator(totalAmount, playerCount);
            const { placesToPay, payouts } = calculator.getFormattedPayouts();
            
            document.getElementById('placesToPay').textContent = placesToPay;
            
            let payoutsHtml = '';
            payouts.forEach(p => {
                payoutsHtml += `<div class="payout-row">
                    <span class="payout-place">${p.place}</span>
                    <span class="payout-amount">${formatCurrency(p.amount)}</span>
                </div>`;
            });
            document.getElementById('payoutsList').innerHTML = payoutsHtml;
            
            let html = buyers.map(buyer => {
                let rowClass = buyer.isPool ? 'pool-row' : (buyer.allPaid ? 'paid' : 'unpaid');
                let badgeClass = buyer.isPool ? 'pool' : (buyer.allPaid ? 'paid' : 'unpaid');
                let badgeText = buyer.isPool ? 'Pool' : (buyer.allPaid ? 'Paid' : 'Unpaid');
                
                return `
                    <div class="buyer-row ${rowClass}">
                        <div class="buyer-name">${buyer.name}</div>
                        <div class="buyer-players">${buyer.players.join(', ')}</div>
                        <div class="buyer-amount">${formatCurrency(buyer.totalAmount)}</div>
                        <div class="status-badge ${badgeClass}">${badgeText}</div>
                    </div>
                `;
            }).join('');
            
            container.innerHTML = html;
            
            requestAnimationFrame(() => {
                const wrapper = document.querySelector('.scroll-wrapper');
                const contentHeight = container.scrollHeight;
                const wrapperHeight = wrapper.clientHeight;
                
                if (contentHeight > wrapperHeight) {
                    container.innerHTML = html + html;
                    startScrolling();
                }
            });
            
            return true;
        }
        
        function startScrolling() {
            const list = document.getElementById('buyerList');
            requestAnimationFrame(() => {
                const contentHeight = list.scrollHeight / 2;
                const duration = contentHeight / 40;
                list.style.animationDuration = `${Math.max(20, duration)}s`;
                list.classList.add('scrolling');
            });
        }
        
        function loadData() {
            fetch('/save_tournament.php')
                .then(response => response.json())
                .then(result => {
                    if (!result.success || !result.data || !result.data.tournaments) {
                        document.getElementById('buyerList').innerHTML = '<div class="no-data">No tournament data</div>';
                        return;
                    }
                    
                    let tournamentData = null;
                    
                    if (tournamentKey && result.data.tournaments[tournamentKey]) {
                        tournamentData = result.data.tournaments[tournamentKey];
                    } else {
                        const keys = Object.keys(result.data.tournaments);
                        if (keys.length > 0) {
                            tournamentData = Object.values(result.data.tournaments)
                                .sort((a, b) => new Date(b.lastUpdated) - new Date(a.lastUpdated))[0];
                        }
                    }
                    
                    if (!tournamentData || !tournamentData.checkedInPlayers) {
                        document.getElementById('buyerList').innerHTML = '<div class="no-data">No tournament data found</div>';
                        return;
                    }
                    
                    if (!tournamentName && tournamentData.tournamentName) {
                        document.getElementById('tournamentName').textContent = tournamentData.tournamentName;
                    }
                    
                    const playerCount = tournamentData.checkedInPlayers.length;
                    const buyers = aggregateBuyers(tournamentData.checkedInPlayers, tournamentData.poolAuction);
                    renderBuyers(buyers, playerCount);
                    
                    document.getElementById('lastUpdated').textContent = 
                        'Updated: ' + new Date().toLocaleTimeString();
                })
                .catch(error => {
                    console.error('Error loading data:', error);
                    document.getElementById('buyerList').innerHTML = '<div class="no-data">Error loading data</div>';
                });
        }
        
        loadData();
        setInterval(loadData, 5000);
        
        window.addEventListener('resize', () => {
            const list = document.getElementById('buyerList');
            if (list.classList.contains('scrolling')) {
                list.classList.remove('scrolling');
                void list.offsetWidth;
                startScrolling();
            }
        });
    </script>
</body>
</html>
